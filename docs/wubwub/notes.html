<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>wubwub.notes API documentation</title>
<meta name="description" content="Notes are objects representing musical notes in wubwub.
They are akin to
MIDI notes in a real DAW; they are used to tell Tracks what musical notes
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wubwub.notes</code></h1>
</header>
<section id="section-intro">
<p>Notes are objects representing musical notes in wubwub.
They are akin to
MIDI notes in a real DAW; they are used to tell Tracks what musical notes
should be played (specifically their pitch, length, and volume).
Note that
the placement of Notes (the beat they are on) is not referenced within the Note
class; that is specified within each Track.</p>
<p>The Note is a single atomic note with a pitch, length, and volume.
Notes can
be combined to create Chords (basically a collection of Notes).
There are also
ArpChords, which are similar to Chords, but are intended to be specifically
used by the <code><a title="wubwub.tracks.Arpeggiator" href="tracks.html#wubwub.tracks.Arpeggiator">Arpeggiator</a></code>.</p>
<h1 id="examples">Examples</h1>
<pre><code class="python">import wubwub as wb
</code></pre>
<h2 id="making-notes">Making Notes</h2>
<p>Notes are initialized with a pitch, length, and volume.</p>
<pre><code class="python"># the most generic note
n = wb.Note(pitch=0, length=1, volume=0)
</code></pre>
<p><strong>Pitch</strong> can be any number (positive or negative, integer or float), which represents the amount of semitones to shift the pitch of the sample being played.
It can instead be in <a href="https://en.wikipedia.org/wiki/Scientific_pitch_notation">scientific pitch notation</a>, in which case it should be a <code>str</code> of a single capital letter corresponding to the pitch, an optional sharp (<code>#</code>) or flat (<code>b</code>), and a number representing the octave.
E.g:</p>
<ul>
<li>Middle C: <code>"C4"</code></li>
<li>1st D sharp above middle C: <code>"D#4"</code></li>
<li>2nd A flat below middle C: <code>"Ab2"</code></li>
<li>A very high G: <code>"G9"</code></li>
</ul>
<p>Using scientific pitch is only really useful if you know the original pitch of the sample (wubwub cannot detect it automatically).
In this case, you will typically set the <code>basepitch</code> attribute of the Track associated with the sample:</p>
<pre><code class="python">seq = wb.Sequencer(bpm=120, beats=8)

# load a sample and encode its true pitch
seq.add_sampler(sample='piano_A4.wav', basepitch='A4', name='piano')
</code></pre>
<p>But for other instruments (particularly drums and sound effects), working with relative pitch in semitones is more straightforward.</p>
<p><strong>Length</strong> is the length of the note in <em>beats</em>.
How long one beat is is dependent on the BPM of the Sequencer.</p>
<p><strong>Volume</strong> is the amount of decibels to change the volume of the sample (negative or positive).
So <code>volume=0</code> means the volume of the sample will not be changed (not that it will be inaudible).</p>
<h2 id="notes-are-immutable">Notes are immutable</h2>
<p>Once a note is initialized, it cannot be changed.</p>
<pre><code class="python">n = wb.Note(pitch=0)
n.pitch = 2
# AttributeError: 'Note' object doesn't support item assignment
</code></pre>
<p>In adding Notes to tracks, you are basically inserting a reference to a particular Note with a set pitch, length, and volume.
Because of this, you can add one Note object to multiple Tracks and not have to worry about the object being altered:</p>
<pre><code class="python">seq = wb.Sequencer(bpm=120, beats=8)

seq.add_sampler(sample='synth1.wav', name='synth')
seq.add_sampler(sample='saxophone.wav', name='sax')

longnote = wb.Note(length=8, volume=2)
seq['synth'][1] = note
seq['sax'][1] = note

# if you could change the Note in synth1, it would change the note in synth2
</code></pre>
<p>To change a Note, you have to overwrite it:</p>
<pre><code class="python">seq['synth'][1] = wb.Note(pitch=4, length=4, volume=1)
</code></pre>
<p>There is an <code>alter</code> method for producing a similar Note from an existing one:</p>
<pre><code class="python">seq['sax'][1] = seq['sax'][0].alter(volume=0)
# the length is still 8, but the volume has been changed from 2 to 0
</code></pre>
<p>Two different Notes will be seen as equal if their pitch, volume, and length, are all equal:</p>
<pre><code class="python">a = wb.Note(pitch=0, length=4, volume=1)
b = wb.Note(pitch=3, length=4, volume=1)

a == b # False
a == b.alter(pitch=0) # True
a == b.alter(pitch='C4') # False
a.alter(pitch='Bb2') == b.alter(pitch='Bb2') # True
</code></pre>
<h2 id="chords">Chords</h2>
<p>Chords are essentially a list of Notes.
They indicate that multiple Notes should be played at the same time on a given beat.
You can make a Chord by gathering a few Notes:</p>
<pre><code class="python">amaj = wb.Chord([
  wb.Note('A4'),
  wb.Note('C#5'),
  wb.Note('E5')
])
</code></pre>
<p>You can also add Notes together to similar effect:</p>
<pre><code class="python">cmin = wb.Note('C5') + wb.Note('Eb5') + wb.Note('G5')
</code></pre>
<p>The Notes are store as a <a href="http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html">SortedList</a>, in order to ensure equivalence when comparing two Chords:</p>
<pre><code class="python">amaj.notes
 # SortedKeyList([Note(pitch=A4, length=1, volume=0), Note(pitch=C#5, length=1, volume=0), Note(pitch=E5, length=1, volume=0)], key=&lt;function Chord.__init__.&lt;locals&gt;.keyfunc at 0x7fb6edc03430&gt;)
</code></pre>
<p>Some other dunder methods are implemented:</p>
<pre><code class="python">amaj == cmin # False, checks if all the Notes of each Chord are equal
len(amaj)    # 3, the number of Notes
iter(amaj)   # for iterating over the Notes of a Chord
amaj[0]      # retrieve the first Note of the Chord
</code></pre>
<p>You can also add Chords to produce new ones:</p>
<pre><code class="python">chord1 = wb.Note('D3') + wb.Note('F3')
chord2 = wb.Note('A3') + wb.Note('C4')
dmin7 = chord1 + chord2
</code></pre>
<p>Like Notes, Chords are also immutable.</p>
<h2 id="arpchord">Arpchord</h2>
<p>There is an additional type of Chord (literally a subclass) called an ArpChord.
It is mainly intended to be used with the Arpeggiator Track.
The main difference between a Chord and an ArpChord is that an ArpChord also has a length for the whole chord:</p>
<pre><code class="python">notes = [wb.Note('D3'), wb.Note('F3'), wb.Note('A3'), wb.Note('C4')]
arp = wb.ArpChord(notes, length=4)
</code></pre>
<p>Even if the individual Notes that make up an ArpChord have different lengths, this length attribute will be used when playing back the arpeggiation.</p>
<p>A normal Chord can also be converted to an ArpChord:</p>
<pre><code class="python">&gt;&gt;&gt; wb.ArpChord(dmin7, length=3)
ArpChord(pitches=['D3', 'F3', 'A3', 'C4'], length=3)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Notes are objects representing musical notes in wubwub.  They are akin to
MIDI notes in a real DAW; they are used to tell Tracks what musical notes
should be played (specifically their pitch, length, and volume).  Note that
the placement of Notes (the beat they are on) is not referenced within the Note
class; that is specified within each Track.

The Note is a single atomic note with a pitch, length, and volume.  Notes can
be combined to create Chords (basically a collection of Notes).  There are also
ArpChords, which are similar to Chords, but are intended to be specifically
used by the `wubwub.tracks.Arpeggiator`.

.. include:: ../docs/notes.md

&#34;&#34;&#34;

__all__ = [&#39;Note&#39;, &#39;Chord&#39;, &#39;ArpChord&#39;, &#39;arpeggiate&#39;,
           &#39;alter_notes&#39;, &#39;new_chord&#39;, &#39;chord_from_name&#39;]

from collections.abc import Iterable
from fractions import Fraction
from itertools import cycle, chain
from sortedcontainers import SortedList

from wubwub.errors import WubWubError
from wubwub.pitch import named_chords, pitch_from_semitones, relative_pitch_to_int
from wubwub.resources import random_choice_generator

class Note(object):
    &#39;&#39;&#39;Class to represent an atomic MIDI-like note in wubwub.&#39;&#39;&#39;
    __slots__ = (&#39;pitch&#39;, &#39;length&#39;, &#39;volume&#39;)

    def __init__(self, pitch=0, length=1, volume=0):
        &#39;&#39;&#39;
        Initialize the note.

        Parameters
        ----------
        pitch : number or str, optional
            Relative pitch in semitones or scientific pitch string.
            The default is 0.
        length : number, optional
            The length of the note in beats. The default is 1.  The
            actual length in seconds is determined by the BPM
            of the Sequencer.
        volume : number, optional
            Relative amount of decibels to change the volume of the
            sample. The default is 0.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        object.__setattr__(self, &#34;pitch&#34;, pitch)
        object.__setattr__(self, &#34;length&#34;, length)
        object.__setattr__(self, &#34;volume&#34;, volume)

    def __setattr__(self, *args):
        &#39;&#39;&#39;Lock setting of attributes for Notes.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item assignment&#34;)

    def __delattr__(self, *args):
        &#39;&#39;&#39;Lock deleting of attributes for Notes.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item deletion&#34;)

    def __repr__(self):
        &#39;&#39;&#39;The string representation of the Note.&#39;&#39;&#39;
        attribs = (&#39;pitch&#39;, &#39;length&#39;, &#39;volume&#39;)
        output = &#39;, &#39;.join([a + &#39;=&#39; + str(getattr(self, a)) for a in attribs])
        return f&#39;Note({output})&#39;

    def __eq__(self, other):
        &#39;&#39;&#39;Check if the other object is a Note where the pitch, length,
        and volume are equal.&#39;&#39;&#39;
        try:
            return all((self.pitch == other.pitch,
                        self.length == other.length,
                        self.volume == other.volume))
        except:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;Create a Chord by summing this and another Note.&#39;&#39;&#39;
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
        else:
            other = [other]
        return Chord([self] + other)

    def __radd__(self, other):
        &#39;&#39;&#39;Create a Chord by summing this and another Note.&#39;&#39;&#39;
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def alter(self, pitch=False, length=False, volume=False):
        &#39;&#39;&#39;
        Create a new note which has the same attributes as self,
        except where specified.

        Parameters
        ----------
        pitch : number or str, optional
            The new pitch. The default is False.
        length : number, optional
            The new length. The default is False.
        volume : number, optional
            The new volume. The default is False.

        Returns
        -------
        wubwub.notes.Note
            The new Note.

        &#39;&#39;&#39;
        pitch = self.pitch if pitch is False else pitch
        length = self.length if length is False else length
        volume = self.volume if volume is False else volume
        return Note(pitch, length, volume)

class Chord(object):
    &#39;&#39;&#39;Class to represent an atomic MIDI-like chord in wubwub.&#39;&#39;&#39;
    __slots__ = (&#39;notes&#39;)
    def __init__(self, notes):
        &#39;&#39;&#39;
        Initialze the Chord with a set of Notes.

        Parameters
        ----------
        notes : list-like
            Collection of `wubwub.notes.Note` objects.  These are added
            to a SortedList, where the key is the pitch.  Any notes with
            scientific pitch notation values for the pitch are given a semitone
            value relative to C4 for sorting purposes.

        Returns
        -------
        None

        &#39;&#39;&#39;
        def keyfunc(note):
            if isinstance(note.pitch, str):
                val = relative_pitch_to_int(&#39;C4&#39;, note.pitch)
            else:
                val = note.pitch
            return val
        object.__setattr__(self, &#34;notes&#34;, SortedList(notes, key=keyfunc))

    def __repr__(self):
        &#39;&#39;&#39;String representation of the Chord.&#39;&#39;&#39;
        pitches = []
        lengths = []
        volumes = []

        for note in self.notes:
            pitches.append(note.pitch)
            lengths.append(note.length)
            volumes.append(note.volume)

        s = f&#39;Chord(pitches={pitches}, lengths={lengths}, volumes={volumes})&#39;
        return s

    def __setattr__(self, *args):
        &#39;&#39;&#39;Lock attribute setting.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item assignment&#34;)

    def __delattr__(self, *args):
        &#39;&#39;&#39;Lock attribute deletion.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item deletion&#34;)

    def __iter__(self):
        &#39;&#39;&#39;Iterate over the Notes of the Chord.&#39;&#39;&#39;
        return iter(self.notes)

    def __getitem__(self, i):
        &#39;&#39;&#39;Return the ith Note of the Chord.&#39;&#39;&#39;
        return self.notes[i]

    def __len__(self):
        &#39;&#39;&#39;Return the number of Notes in the Chord.&#39;&#39;&#39;
        return len(self.notes)

    def __eq__(self, other):
        &#39;&#39;&#39;Check for equivalence with another Chord.  Returns True only if
        other is of the same length of self, and if all of its `notes`
        are equal to all the `notes` of self.&#39;&#39;&#39;
        try:
            return (len(self) == len(other) and
                    all((a == b for a, b in zip(self.notes, other.notes))))
        except:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;Create a new Chord by adding another Note or Chord.&#39;&#39;&#39;
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
        else:
            other = [other]
        return Chord(self.notes + other)

    def __radd__(self, other):
        &#39;&#39;&#39;Create a new Chord by adding another Note or Chord.&#39;&#39;&#39;
        if other == 0:
            return self
        else:
            return self.__add__(other)

    @property
    def pitches(self):
        &#39;&#39;&#39;Return the `pitch` value for each Note.&#39;&#39;&#39;
        return [note.pitch for note in self.notes]

    @property
    def lengths(self):
        &#39;&#39;&#39;Return the `length` value for each Note.&#39;&#39;&#39;
        return [note.length for note in self.notes]

    @property
    def volumes(self):
        &#39;&#39;&#39;Return the `volume` value for each Note.&#39;&#39;&#39;
        return [note.volume for note in self.notes]

class ArpChord(Chord):
    __slots__ = (&#39;notes&#39;, &#39;length&#39;)
    def __init__(self, notes, length):
        super().__init__(notes)
        object.__setattr__(self, &#34;length&#34;, length)

    def __repr__(self):
        pitches = [note.pitch for note in self.notes]
        s = f&#39;ArpChord(pitches={pitches}, length={self.length})&#39;
        return s

    def __eq__(self, other):
        try:
            return (len(self) == len(other) and
                    all((a == b for a, b in zip(self.notes, other.notes))) and
                    self.length == other.length)
        except:
            return False

    def __add__(self, other):
        newl = self.length
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
            if hasattr(other, &#39;length&#39;):
                newl = max(newl, other.length)
        else:
            other = [other]
        return ArpChord(self.notes + other, newl)

    def __radd__(self, other):
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def changelength(self, newlength):
        return ArpChord(self.notes, newlength)


_notetypes_ = [Note, Chord, ArpChord]

def arpeggio_generator(notes, method):
    methods = [&#39;up&#39;, &#39;down&#39;, &#39;updown&#39;, &#39;downup&#39;, &#39;up&amp;down&#39;, &#39;down&amp;up&#39;,
               &#39;random&#39;]
    if method not in methods:
        formatted = &#39;, &#39;.join(m for m in methods)
        raise WubWubError(f&#39;method must be in {formatted}&#39;)

    if method == &#39;up&#39;:
        return cycle(notes)
    if method == &#39;down&#39;:
        return cycle(notes[::-1])
    if method == &#39;updown&#39;:
        return cycle(chain(notes, notes[-2:0:-1]))
    if method == &#39;downup&#39;:
        return cycle(chain(notes[::-1], notes[1:-1]))
    if method == &#39;up&amp;down&#39;:
        return cycle(chain(notes, notes[::-1]))
    if method == &#39;down&amp;up&#39;:
        return cycle(chain(notes[::-1], notes))
    if method == &#39;random&#39;:
        return random_choice_generator(notes)

def arpeggiate(chord, beat, length=None, freq=0.5, method=&#39;up&#39;, auto_chord_length=&#39;max&#39;):

    notes = chord.notes

    if length is None:
        if isinstance(chord, ArpChord):
            length = chord.length

        elif isinstance(chord, Chord):
            choices = {&#39;min&#39;:min, &#39;max&#39;:max}
            length = choices[auto_chord_length]([note.length for note in notes])

        else:
            raise WubWubError(&#39;chord must be wubwub.Chord or wubwub.ArpChord&#39;)

    freq = Fraction(freq).limit_denominator()
    current = Fraction(beat).limit_denominator()
    end = beat + length
    arpeggiated = {}
    gen = arpeggio_generator(notes, method)

    while current &lt; end:
        note = next(gen)
        notelength = freq if current + freq &lt;= end else end-current
        pos = current.numerator / current.denominator
        notelength = notelength.numerator / notelength.denominator
        arpeggiated[pos] = Note(pitch=note.pitch, length=notelength,
                                volume=note.volume)
        current += freq

    return arpeggiated

def alter_notes(array, pitch=False, length=False, volume=False):
    return [n.alter(pitch, length, volume) for n in array]

def new_chord(pitches, lengths=1, volumes=0):
    size = len(pitches)
    if not isinstance(lengths, Iterable):
        lengths = [lengths] * size
    if not isinstance(volumes, Iterable):
        volumes = [volumes] * size

    notes = [Note(p, l, v) for p, l, v in zip(pitches, lengths, volumes)]
    return Chord(notes)

def chord_from_name(root, kind=&#39;&#39;, voicing=0, lengths=1, volumes=0, add=None):
    try:
        pitches = list(named_chords[kind])
    except KeyError:
        raise WubWubError(f&#39;Chord &#34;{kind}&#34; either not recognized or not &#39;
                          &#39;implemented.&#39;)

    if add is None:
        add = []

    if add:
        if not isinstance(add, Iterable):
            add = [add]
        pitches += add
    if isinstance(root, str):
        pitches = [pitch_from_semitones(root, p) for p in pitches]
    return new_chord(pitches, lengths, volumes)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wubwub.notes.alter_notes"><code class="name flex">
<span>def <span class="ident">alter_notes</span></span>(<span>array, pitch=False, length=False, volume=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter_notes(array, pitch=False, length=False, volume=False):
    return [n.alter(pitch, length, volume) for n in array]</code></pre>
</details>
</dd>
<dt id="wubwub.notes.arpeggiate"><code class="name flex">
<span>def <span class="ident">arpeggiate</span></span>(<span>chord, beat, length=None, freq=0.5, method='up', auto_chord_length='max')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def arpeggiate(chord, beat, length=None, freq=0.5, method=&#39;up&#39;, auto_chord_length=&#39;max&#39;):

    notes = chord.notes

    if length is None:
        if isinstance(chord, ArpChord):
            length = chord.length

        elif isinstance(chord, Chord):
            choices = {&#39;min&#39;:min, &#39;max&#39;:max}
            length = choices[auto_chord_length]([note.length for note in notes])

        else:
            raise WubWubError(&#39;chord must be wubwub.Chord or wubwub.ArpChord&#39;)

    freq = Fraction(freq).limit_denominator()
    current = Fraction(beat).limit_denominator()
    end = beat + length
    arpeggiated = {}
    gen = arpeggio_generator(notes, method)

    while current &lt; end:
        note = next(gen)
        notelength = freq if current + freq &lt;= end else end-current
        pos = current.numerator / current.denominator
        notelength = notelength.numerator / notelength.denominator
        arpeggiated[pos] = Note(pitch=note.pitch, length=notelength,
                                volume=note.volume)
        current += freq

    return arpeggiated</code></pre>
</details>
</dd>
<dt id="wubwub.notes.chord_from_name"><code class="name flex">
<span>def <span class="ident">chord_from_name</span></span>(<span>root, kind='', voicing=0, lengths=1, volumes=0, add=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chord_from_name(root, kind=&#39;&#39;, voicing=0, lengths=1, volumes=0, add=None):
    try:
        pitches = list(named_chords[kind])
    except KeyError:
        raise WubWubError(f&#39;Chord &#34;{kind}&#34; either not recognized or not &#39;
                          &#39;implemented.&#39;)

    if add is None:
        add = []

    if add:
        if not isinstance(add, Iterable):
            add = [add]
        pitches += add
    if isinstance(root, str):
        pitches = [pitch_from_semitones(root, p) for p in pitches]
    return new_chord(pitches, lengths, volumes)</code></pre>
</details>
</dd>
<dt id="wubwub.notes.new_chord"><code class="name flex">
<span>def <span class="ident">new_chord</span></span>(<span>pitches, lengths=1, volumes=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_chord(pitches, lengths=1, volumes=0):
    size = len(pitches)
    if not isinstance(lengths, Iterable):
        lengths = [lengths] * size
    if not isinstance(volumes, Iterable):
        volumes = [volumes] * size

    notes = [Note(p, l, v) for p, l, v in zip(pitches, lengths, volumes)]
    return Chord(notes)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wubwub.notes.ArpChord"><code class="flex name class">
<span>class <span class="ident">ArpChord</span></span>
<span>(</span><span>notes, length)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an atomic MIDI-like chord in wubwub.</p>
<p>Initialze the Chord with a set of Notes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>notes</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of <code><a title="wubwub.notes.Note" href="#wubwub.notes.Note">Note</a></code> objects.
These are added
to a SortedList, where the key is the pitch.
Any notes with
scientific pitch notation values for the pitch are given a semitone
value relative to C4 for sorting purposes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ArpChord(Chord):
    __slots__ = (&#39;notes&#39;, &#39;length&#39;)
    def __init__(self, notes, length):
        super().__init__(notes)
        object.__setattr__(self, &#34;length&#34;, length)

    def __repr__(self):
        pitches = [note.pitch for note in self.notes]
        s = f&#39;ArpChord(pitches={pitches}, length={self.length})&#39;
        return s

    def __eq__(self, other):
        try:
            return (len(self) == len(other) and
                    all((a == b for a, b in zip(self.notes, other.notes))) and
                    self.length == other.length)
        except:
            return False

    def __add__(self, other):
        newl = self.length
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
            if hasattr(other, &#39;length&#39;):
                newl = max(newl, other.length)
        else:
            other = [other]
        return ArpChord(self.notes + other, newl)

    def __radd__(self, other):
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def changelength(self, newlength):
        return ArpChord(self.notes, newlength)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.notes.Chord" href="#wubwub.notes.Chord">Chord</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wubwub.notes.ArpChord.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wubwub.notes.ArpChord.changelength"><code class="name flex">
<span>def <span class="ident">changelength</span></span>(<span>self, newlength)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def changelength(self, newlength):
    return ArpChord(self.notes, newlength)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="wubwub.notes.Chord" href="#wubwub.notes.Chord">Chord</a></b></code>:
<ul class="hlist">
<li><code><a title="wubwub.notes.Chord.lengths" href="#wubwub.notes.Chord.lengths">lengths</a></code></li>
<li><code><a title="wubwub.notes.Chord.notes" href="#wubwub.notes.Chord.notes">notes</a></code></li>
<li><code><a title="wubwub.notes.Chord.pitches" href="#wubwub.notes.Chord.pitches">pitches</a></code></li>
<li><code><a title="wubwub.notes.Chord.volumes" href="#wubwub.notes.Chord.volumes">volumes</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="wubwub.notes.Chord"><code class="flex name class">
<span>class <span class="ident">Chord</span></span>
<span>(</span><span>notes)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an atomic MIDI-like chord in wubwub.</p>
<p>Initialze the Chord with a set of Notes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>notes</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Collection of <code><a title="wubwub.notes.Note" href="#wubwub.notes.Note">Note</a></code> objects.
These are added
to a SortedList, where the key is the pitch.
Any notes with
scientific pitch notation values for the pitch are given a semitone
value relative to C4 for sorting purposes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chord(object):
    &#39;&#39;&#39;Class to represent an atomic MIDI-like chord in wubwub.&#39;&#39;&#39;
    __slots__ = (&#39;notes&#39;)
    def __init__(self, notes):
        &#39;&#39;&#39;
        Initialze the Chord with a set of Notes.

        Parameters
        ----------
        notes : list-like
            Collection of `wubwub.notes.Note` objects.  These are added
            to a SortedList, where the key is the pitch.  Any notes with
            scientific pitch notation values for the pitch are given a semitone
            value relative to C4 for sorting purposes.

        Returns
        -------
        None

        &#39;&#39;&#39;
        def keyfunc(note):
            if isinstance(note.pitch, str):
                val = relative_pitch_to_int(&#39;C4&#39;, note.pitch)
            else:
                val = note.pitch
            return val
        object.__setattr__(self, &#34;notes&#34;, SortedList(notes, key=keyfunc))

    def __repr__(self):
        &#39;&#39;&#39;String representation of the Chord.&#39;&#39;&#39;
        pitches = []
        lengths = []
        volumes = []

        for note in self.notes:
            pitches.append(note.pitch)
            lengths.append(note.length)
            volumes.append(note.volume)

        s = f&#39;Chord(pitches={pitches}, lengths={lengths}, volumes={volumes})&#39;
        return s

    def __setattr__(self, *args):
        &#39;&#39;&#39;Lock attribute setting.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item assignment&#34;)

    def __delattr__(self, *args):
        &#39;&#39;&#39;Lock attribute deletion.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item deletion&#34;)

    def __iter__(self):
        &#39;&#39;&#39;Iterate over the Notes of the Chord.&#39;&#39;&#39;
        return iter(self.notes)

    def __getitem__(self, i):
        &#39;&#39;&#39;Return the ith Note of the Chord.&#39;&#39;&#39;
        return self.notes[i]

    def __len__(self):
        &#39;&#39;&#39;Return the number of Notes in the Chord.&#39;&#39;&#39;
        return len(self.notes)

    def __eq__(self, other):
        &#39;&#39;&#39;Check for equivalence with another Chord.  Returns True only if
        other is of the same length of self, and if all of its `notes`
        are equal to all the `notes` of self.&#39;&#39;&#39;
        try:
            return (len(self) == len(other) and
                    all((a == b for a, b in zip(self.notes, other.notes))))
        except:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;Create a new Chord by adding another Note or Chord.&#39;&#39;&#39;
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
        else:
            other = [other]
        return Chord(self.notes + other)

    def __radd__(self, other):
        &#39;&#39;&#39;Create a new Chord by adding another Note or Chord.&#39;&#39;&#39;
        if other == 0:
            return self
        else:
            return self.__add__(other)

    @property
    def pitches(self):
        &#39;&#39;&#39;Return the `pitch` value for each Note.&#39;&#39;&#39;
        return [note.pitch for note in self.notes]

    @property
    def lengths(self):
        &#39;&#39;&#39;Return the `length` value for each Note.&#39;&#39;&#39;
        return [note.length for note in self.notes]

    @property
    def volumes(self):
        &#39;&#39;&#39;Return the `volume` value for each Note.&#39;&#39;&#39;
        return [note.volume for note in self.notes]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wubwub.notes.ArpChord" href="#wubwub.notes.ArpChord">ArpChord</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wubwub.notes.Chord.lengths"><code class="name">var <span class="ident">lengths</span></code></dt>
<dd>
<div class="desc"><p>Return the <code>length</code> value for each Note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lengths(self):
    &#39;&#39;&#39;Return the `length` value for each Note.&#39;&#39;&#39;
    return [note.length for note in self.notes]</code></pre>
</details>
</dd>
<dt id="wubwub.notes.Chord.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="wubwub.notes.Chord.pitches"><code class="name">var <span class="ident">pitches</span></code></dt>
<dd>
<div class="desc"><p>Return the <code>pitch</code> value for each Note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pitches(self):
    &#39;&#39;&#39;Return the `pitch` value for each Note.&#39;&#39;&#39;
    return [note.pitch for note in self.notes]</code></pre>
</details>
</dd>
<dt id="wubwub.notes.Chord.volumes"><code class="name">var <span class="ident">volumes</span></code></dt>
<dd>
<div class="desc"><p>Return the <code>volume</code> value for each Note.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def volumes(self):
    &#39;&#39;&#39;Return the `volume` value for each Note.&#39;&#39;&#39;
    return [note.volume for note in self.notes]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.notes.Note"><code class="flex name class">
<span>class <span class="ident">Note</span></span>
<span>(</span><span>pitch=0, length=1, volume=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to represent an atomic MIDI-like note in wubwub.</p>
<p>Initialize the note.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pitch</code></strong> :&ensp;<code>number</code> or <code>str</code>, optional</dt>
<dd>Relative pitch in semitones or scientific pitch string.
The default is 0.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>number</code>, optional</dt>
<dd>The length of the note in beats. The default is 1.
The
actual length in seconds is determined by the BPM
of the Sequencer.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>number</code>, optional</dt>
<dd>Relative amount of decibels to change the volume of the
sample. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Note(object):
    &#39;&#39;&#39;Class to represent an atomic MIDI-like note in wubwub.&#39;&#39;&#39;
    __slots__ = (&#39;pitch&#39;, &#39;length&#39;, &#39;volume&#39;)

    def __init__(self, pitch=0, length=1, volume=0):
        &#39;&#39;&#39;
        Initialize the note.

        Parameters
        ----------
        pitch : number or str, optional
            Relative pitch in semitones or scientific pitch string.
            The default is 0.
        length : number, optional
            The length of the note in beats. The default is 1.  The
            actual length in seconds is determined by the BPM
            of the Sequencer.
        volume : number, optional
            Relative amount of decibels to change the volume of the
            sample. The default is 0.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        object.__setattr__(self, &#34;pitch&#34;, pitch)
        object.__setattr__(self, &#34;length&#34;, length)
        object.__setattr__(self, &#34;volume&#34;, volume)

    def __setattr__(self, *args):
        &#39;&#39;&#39;Lock setting of attributes for Notes.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item assignment&#34;)

    def __delattr__(self, *args):
        &#39;&#39;&#39;Lock deleting of attributes for Notes.&#39;&#39;&#39;
        name = self.__class__.__name__
        raise AttributeError(f&#34;&#39;{name}&#39; object doesn&#39;t support item deletion&#34;)

    def __repr__(self):
        &#39;&#39;&#39;The string representation of the Note.&#39;&#39;&#39;
        attribs = (&#39;pitch&#39;, &#39;length&#39;, &#39;volume&#39;)
        output = &#39;, &#39;.join([a + &#39;=&#39; + str(getattr(self, a)) for a in attribs])
        return f&#39;Note({output})&#39;

    def __eq__(self, other):
        &#39;&#39;&#39;Check if the other object is a Note where the pitch, length,
        and volume are equal.&#39;&#39;&#39;
        try:
            return all((self.pitch == other.pitch,
                        self.length == other.length,
                        self.volume == other.volume))
        except:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;Create a Chord by summing this and another Note.&#39;&#39;&#39;
        if hasattr(other, &#39;notes&#39;):
            other = other.notes
        else:
            other = [other]
        return Chord([self] + other)

    def __radd__(self, other):
        &#39;&#39;&#39;Create a Chord by summing this and another Note.&#39;&#39;&#39;
        if other == 0:
            return self
        else:
            return self.__add__(other)

    def alter(self, pitch=False, length=False, volume=False):
        &#39;&#39;&#39;
        Create a new note which has the same attributes as self,
        except where specified.

        Parameters
        ----------
        pitch : number or str, optional
            The new pitch. The default is False.
        length : number, optional
            The new length. The default is False.
        volume : number, optional
            The new volume. The default is False.

        Returns
        -------
        wubwub.notes.Note
            The new Note.

        &#39;&#39;&#39;
        pitch = self.pitch if pitch is False else pitch
        length = self.length if length is False else length
        volume = self.volume if volume is False else volume
        return Note(pitch, length, volume)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="wubwub.notes.Note.length"><code class="name">var <span class="ident">length</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="wubwub.notes.Note.pitch"><code class="name">var <span class="ident">pitch</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="wubwub.notes.Note.volume"><code class="name">var <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wubwub.notes.Note.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>self, pitch=False, length=False, volume=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new note which has the same attributes as self,
except where specified.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pitch</code></strong> :&ensp;<code>number</code> or <code>str</code>, optional</dt>
<dd>The new pitch. The default is False.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>number</code>, optional</dt>
<dd>The new length. The default is False.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>number</code>, optional</dt>
<dd>The new volume. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="wubwub.notes.Note" href="#wubwub.notes.Note">Note</a></code></dt>
<dd>The new Note.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter(self, pitch=False, length=False, volume=False):
    &#39;&#39;&#39;
    Create a new note which has the same attributes as self,
    except where specified.

    Parameters
    ----------
    pitch : number or str, optional
        The new pitch. The default is False.
    length : number, optional
        The new length. The default is False.
    volume : number, optional
        The new volume. The default is False.

    Returns
    -------
    wubwub.notes.Note
        The new Note.

    &#39;&#39;&#39;
    pitch = self.pitch if pitch is False else pitch
    length = self.length if length is False else length
    volume = self.volume if volume is False else volume
    return Note(pitch, length, volume)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#examples">Examples</a><ul>
<li><a href="#making-notes">Making Notes</a></li>
<li><a href="#notes-are-immutable">Notes are immutable</a></li>
<li><a href="#chords">Chords</a></li>
<li><a href="#arpchord">Arpchord</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wubwub" href="index.html">wubwub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wubwub.notes.alter_notes" href="#wubwub.notes.alter_notes">alter_notes</a></code></li>
<li><code><a title="wubwub.notes.arpeggiate" href="#wubwub.notes.arpeggiate">arpeggiate</a></code></li>
<li><code><a title="wubwub.notes.chord_from_name" href="#wubwub.notes.chord_from_name">chord_from_name</a></code></li>
<li><code><a title="wubwub.notes.new_chord" href="#wubwub.notes.new_chord">new_chord</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wubwub.notes.ArpChord" href="#wubwub.notes.ArpChord">ArpChord</a></code></h4>
<ul class="">
<li><code><a title="wubwub.notes.ArpChord.changelength" href="#wubwub.notes.ArpChord.changelength">changelength</a></code></li>
<li><code><a title="wubwub.notes.ArpChord.length" href="#wubwub.notes.ArpChord.length">length</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.notes.Chord" href="#wubwub.notes.Chord">Chord</a></code></h4>
<ul class="">
<li><code><a title="wubwub.notes.Chord.lengths" href="#wubwub.notes.Chord.lengths">lengths</a></code></li>
<li><code><a title="wubwub.notes.Chord.notes" href="#wubwub.notes.Chord.notes">notes</a></code></li>
<li><code><a title="wubwub.notes.Chord.pitches" href="#wubwub.notes.Chord.pitches">pitches</a></code></li>
<li><code><a title="wubwub.notes.Chord.volumes" href="#wubwub.notes.Chord.volumes">volumes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.notes.Note" href="#wubwub.notes.Note">Note</a></code></h4>
<ul class="">
<li><code><a title="wubwub.notes.Note.alter" href="#wubwub.notes.Note.alter">alter</a></code></li>
<li><code><a title="wubwub.notes.Note.length" href="#wubwub.notes.Note.length">length</a></code></li>
<li><code><a title="wubwub.notes.Note.pitch" href="#wubwub.notes.Note.pitch">pitch</a></code></li>
<li><code><a title="wubwub.notes.Note.volume" href="#wubwub.notes.Note.volume">volume</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>