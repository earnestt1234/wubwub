<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>wubwub.tracks API documentation</title>
<meta name="description" content="Created on Tue Feb
9 10:10:34 2021 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wubwub.tracks</code></h1>
</header>
<section id="section-intro">
<p>Created on Tue Feb
9 10:10:34 2021</p>
<p>@author: earnestt1234</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
Created on Tue Feb  9 10:10:34 2021

@author: earnestt1234
&#34;&#34;&#34;

from abc import ABCMeta, abstractmethod
from collections.abc import Iterable
from collections import defaultdict
import copy
from fractions import Fraction
import itertools
from numbers import Number
import os
import pprint
import warnings

import numpy as np
import pydub
from sortedcontainers import SortedDict

from wubwub.audio import add_note_to_audio, add_effects, play, _overhang_to_milli
from wubwub.errors import WubWubError, WubWubWarning
from wubwub.notes import ArpChord, Chord, Note, arpeggiate, _notetypes_
from wubwub.plots import trackplot, pianoroll
from wubwub.resources import random_choice_generator, MINUTE, SECOND

class SliceableDict:
    def __init__(self, d):
        self.d = d

    def __getitem__(self, keys):
        if isinstance(keys, Number):
            return {keys: self.d[keys]}
        elif isinstance(keys, slice):
            start, stop = (keys.start, keys.stop)
            start = 0 if start is None else start
            stop = np.inf if stop is None else stop
            return {k:v for k, v in self.d.items()
                    if start &lt;= k &lt; stop}
        elif isinstance(keys, Iterable):
            if getattr(keys, &#39;dtype&#39;, False) == bool:
                if not len(keys) == len(self.d):
                    raise IndexError(f&#39;Length of boolean index ({len(keys)}) &#39;
                                     f&#34;does not match size of dict ({len(self)}).&#34;)
                return {k:v for boolean, (k, v) in
                        zip(keys, self.d.items()) if boolean}

            else:
                return {k: dict.get(self.d, k) for k in keys}
        else:
            raise IndexError(&#39;Could not interpret input as int, &#39;
                             &#39;slice, iterable, or boolean index.&#39;)

class Track(metaclass=ABCMeta):

    handle_outside_notes = &#39;skip&#39;

    def __init__(self, name, sequencer,):
        self.notedict = SortedDict()
        self.samplepath = None

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._name = None
        self._sample = None
        self._sequencer = None
        self.sequencer = sequencer
        self.name = name

        self.plotting = {}

    def __getitem__(self, beat):
        if isinstance(beat, Number):
            return self.notedict[beat]
        elif isinstance(beat, slice):
            start, stop = (beat.start, beat.stop)
            start = 0 if start is None else start
            stop = np.inf if stop is None else stop
            return [self.notedict[k] for k in self.notedict.keys() if start &lt;= k &lt; stop]
        elif isinstance(beat, Iterable):
            if getattr(beat, &#39;dtype&#39;, False) == bool:
                if not len(beat) == len(self.notedict):
                    raise IndexError(f&#39;Length of boolean index ({len(beat)}) &#39;
                                     f&#34;does not match number of notes ({len(self.notedict)}).&#34;)
                return [self.notedict[k] for k, b in zip(self.notedict.keys(), beat)
                        if b]

            else:
                return [self.notedict[b] for b in beat]
        else:
            raise WubWubError(&#39;Index wubwub.Track with [beat], &#39;
                              &#39;[start:stop], or boolean index, &#39;
                              f&#39;not {type(beat)}&#39;)

    def __setitem__(self, beat, value):
        if isinstance(beat, Number):
            self.notedict[beat] = value
        elif isinstance(beat, slice):
            start, stop, step = (beat.start, beat.stop, beat.step)
            if step is None:
                # replace all notes in the range
                start = 0 if start is None else start
                stop = np.inf if stop is None else stop
                for k, v in self.notedict.items():
                    if k &lt; start:
                        continue
                    if k &gt;= stop:
                        break
                    self.notedict[k] = value
            else:
                # fill notes from start to stop every step
                start = 1 if start is None else start
                stop = self.get_beats() + 1 if stop is None else stop
                while start &lt; stop:
                    self.notedict[start] = value
                    start += step
        elif isinstance(beat, Iterable):
            if getattr(beat, &#39;dtype&#39;, False) == bool:
                if not len(beat) == len(self.notedict):
                    raise IndexError(f&#39;Length of boolean index ({len(beat)}) &#39;
                                     f&#34;does not match number of notes ({len(self.notedict)}).&#34;)
                if not type(value) in _notetypes_:
                    raise IndexError(&#39;Can only set with single note using &#39;
                                     &#39;boolean index.&#39;)
                for k, b in zip(self.notedict.keys(), beat):
                    if b:
                        self.notedict[k] = value
            else:
                if type(value) in _notetypes_:
                    value = [value] * len(beat)
                if len(beat) != len(value):
                    raise IndexError(f&#39;Length of new values ({len(value)}) &#39;
                                     &#39;does not equal length of indexer &#39;
                                     f&#39;({len(beat)}).&#39;)
                for b, v in zip(beat, value):
                    self.notedict[b] = v

        else:
            raise WubWubError(&#39;Index wubwub.Track with [beat], &#39;
                              &#39;[start:stop], or boolean index, &#39;
                              f&#39;not {type(beat)}&#39;)

    @property
    def slice(self):
        return SliceableDict(self.notedict)

    @property
    def sequencer(self):
        return self._sequencer

    @sequencer.setter
    def sequencer(self, sequencer):
        if sequencer == None:
            self._sequencer = None
            return

        if self._name in sequencer.tracknames():
            raise WubWubError(f&#39;name &#34;{self._name}&#34; already in use by new sequencer&#39;)

        if self._sequencer is not None:
            self._sequencer.delete_track(self)

        self._sequencer = sequencer
        self._sequencer._add_track(self)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, new):
        if self.sequencer and new in self.sequencer.tracknames():
            raise WubWubError(f&#39;track name &#34;{new}&#34; already in use.&#39;)
        self._name = new

    def add(self, beat, element, merge=False, outsiders=None):

        if beat &gt;= self.get_beats() + 1:
            method = self.handle_outside_notes if outsiders is None else outsiders
            options = [&#39;skip&#39;, &#39;add&#39;, &#39;warn&#39;, &#39;raise&#39;]
            if method not in options:
                w = (&#39;`method` not recognized, &#39;
                     &#39;defaulting to &#34;skip&#34;.&#39;,)
                warnings.warn(w, WubWubWarning)
                method = &#39;skip&#39;
            if method == &#39;skip&#39;:
                return
            if method == &#39;warn&#39;:
                s = (&#34;Adding note on beat beyond the &#34;
                     &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                     &#34;in class docstring for `wb.Track` to toggle &#34;
                     &#34;this behavior.&#34;)
                warnings.warn(s, WubWubWarning)

            elif method == &#39;raise&#39;:
                s = (&#34;Tried to add note on beat beyond the &#34;
                     &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                     &#34;in class docstring for `wb.Track` to toggle &#34;
                     &#34;this behavior.&#34;)
                raise WubWubError(s)
        existing = self.notedict.get(beat, None)
        if existing and merge:
            element = existing + element
        self.notedict[beat] = element

    def add_fromdict(self, d, offset=0, outsiders=None, merge=False):
        for beat, element in d.items():

            self.add(beat=beat + offset, element=element, merge=merge,
                     outsiders=outsiders)

    def array_of_beats(self):
        return np.array(self.notedict.keys())

    def copy(self, newname=None, newseq=False, with_notes=True,):
        if newname is None:
            newname = self.name
        if newseq is False:
            newseq = self.sequencer
        new = copy.copy(self)
        for k, v in vars(new).items():
            if k == &#39;notedict&#39;:
                setattr(new, k, v.copy())
            elif k == &#39;_name&#39;:
                setattr(new, k, newname)
            elif k == &#39;_sequencer&#39;:
                setattr(new, k, None)
            else:
                setattr(new, k, copy.deepcopy(v))
        new.sequencer = newseq
        if not with_notes:
            new.delete_all()
        return new

    def copypaste(self, start, stop, newstart, outsiders=None, merge=False,):
        section = self.slice[start:stop]
        if section:
            offset = start - 1
            at_one = {k-offset:v for k, v in section.items()}
            self.add_fromdict(at_one, offset=newstart-1)

    def _handle_beats_dict_boolarray(self, beats):
        if getattr(beats, &#39;dtype&#39;, False) == bool:
            beats = self[beats].keys()
        elif isinstance(beats, dict):
            beats = beats.keys()
        elif isinstance(beats, Number):
            return [beats]
        return beats

    def quantize(self, resolution=1/4, merge=False):
        bts = self.get_beats()
        targets = np.empty(0)
        if isinstance(resolution, Number):
            resolution = [resolution]
        for r in resolution:
            if ((1 / r) % 1) != 0:
                raise WubWubError(&#39;`resolution` must evenly divide 1&#39;)
            steps = int(bts * (1 / r))
            beats = np.linspace(1, bts + 1, steps, endpoint=False)
            targets = np.append(targets, beats)
        targets = np.unique(targets)
        for b, note in self.notedict.copy().items():
            diffs = np.abs(targets - b)
            argmin = np.argmin(diffs)
            closest = targets[argmin]
            if b != closest:
                del self.notedict[b]
                self.add(closest, note, merge=merge)

    def shift(self, beats, by, merge=False):
        beats = self._handle_beats_dict_boolarray(beats)
        newkeys = [k + by if k in beats else k
                   for k in self.notedict.keys()]
        oldnotes = self.notedict.values()
        self.delete_all_notes()
        for newbeat, note in zip(newkeys, oldnotes):
            self.add(newbeat, note, merge=merge)

    def get_bpm(self):
        return self.sequencer.bpm

    def get_beats(self):
        return self.sequencer.beats

    def count_by_beat(self, res=1):
        out = defaultdict(int)
        res = 1/res
        for beat in self.array_of_beats():
            out[np.floor(beat * res) / res] += 1

        return dict(out)

    def pprint_notedict(self):
        pprint.pprint(self.notedict)

    def clean(self):
        maxi = self.get_beats()
        self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                    if 1 &lt;= b &lt; maxi +1})

    def delete_all(self):
        self.notedict = SortedDict({})

    def delete(self, beats):
        beats = self._handle_beats_dict_boolarray(beats)
        for beat in beats:
            del self.notedict[beat]

    def delete_fromrange(self, lo, hi):
        self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                    if not lo &lt;= b &lt; hi})

    def unpack_notes(self, start=0, stop=np.inf,):
        unpacked = []
        for b, element in self.notedict.items():
            if not start &lt;= b &lt; stop:
                continue
            if isinstance(element, Note):
                unpacked.append((b, element))
            elif type(element) in [Chord, ArpChord]:
                for note in element.notes:
                    unpacked.append((b, note))
        return unpacked

    @abstractmethod
    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        pass

    def postprocess(self, build):
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    @abstractmethod
    def soundtest(self, duration=None, postprocess=True,):
        pass

    def plot(self, yaxis=&#39;semitones&#39;, timesig=4, grid=True, ax=None,
             plot_kwds=None, scatter_kwds=None):
        return trackplot(track=self,
                         yaxis=yaxis,
                         timesig=timesig,
                         grid=grid,
                         ax=ax,
                         plot_kwds=plot_kwds,
                         scatter_kwds=scatter_kwds)

    def pianoroll(self, timesig=4, grid=True,):
        return pianoroll(track=self, timesig=timesig, grid=grid)

class SamplerLikeTrack(Track):
    def __init__(self, name, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer)

    def make_notes(self, beats, pitches=0, lengths=1, volumes=0,
                   pitch_select=&#39;cycle&#39;, length_select=&#39;cycle&#39;,
                   volume_select=&#39;cycle&#39;, merge=False):

        if not isinstance(beats, Iterable):
            beats = [beats]

        pitches = self._convert_select_arg(pitches, pitch_select)
        lengths = self._convert_select_arg(lengths, length_select)
        volumes = self._convert_select_arg(volumes, volume_select)

        d = {b : Note(next(pitches), next(lengths), next(volumes))
             for b in beats}

        self.add_fromdict(d, merge=merge)

    def make_notes_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                         start=1, end=None, pitch_select=&#39;cycle&#39;,
                         length_select=&#39;cycle&#39;, volume_select=&#39;cycle&#39;, merge=False):

        freq = Fraction(freq).limit_denominator()

        pitches = self._convert_select_arg(pitches, pitch_select)
        lengths = self._convert_select_arg(lengths, length_select)
        volumes = self._convert_select_arg(volumes, volume_select)

        b = Fraction(start + offset).limit_denominator()
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            pos = b.numerator / b.denominator
            d[pos] = Note(next(pitches), next(lengths), next(volumes))
            b += freq

        self.add_fromdict(d, merge=merge)

    def make_chord(self, beat, pitches, lengths=1, volumes=0, merge=False):
        chord = self._make_chord_assemble(pitches, lengths, volumes)
        self.add(beat, chord, merge=merge)

    def make_chord_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                         start=1, end=None, merge=False):

        freq = Fraction(freq).limit_denominator()

        chord = self._make_chord_assemble(pitches, lengths, volumes)
        b = Fraction(start + offset).limit_denominator()
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            pos = b.numerator / b.denominator
            d[pos] = chord
            b += freq
        self.add_fromdict(d, merge=merge)

    def _make_chord_assemble(self, pitches, lengths, volumes):
        if not isinstance(pitches, Iterable) or isinstance(pitches, str):
            pitches = [pitches]

        if isinstance(lengths, Number):
            lengths = [lengths] * len(pitches)

        if isinstance(volumes, Number):
            volumes = [volumes] * len(pitches)

        notes = [Note(p, l, v) for p, l, v in zip(pitches, lengths, volumes)]
        return Chord(notes)

    def _convert_select_arg(self, arg, option):
        if not isinstance(arg, Iterable) or isinstance(arg, str):
            arg = [arg]

        if option == &#39;cycle&#39;:
            return itertools.cycle(arg)
        elif option == &#39;random&#39;:
            return random_choice_generator(arg)
        else:
            raise WubWubError(&#39;pitch, length, and volume select must be &#39;,
                              &#39;&#34;cycle&#34; or &#34;random&#34;.&#39;)

class SingleSampleTrack(Track):
    def __init__(self, name, sample, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer, **kwargs)
        self._sample = None
        self.sample = sample

    @property
    def sample(self):
        return self._sample

    @sample.setter
    def sample(self, sample):
        if isinstance(sample, str):
            _, ext = os.path.splitext(sample)
            ext = ext.lower().strip(&#39;.&#39;)
            self._sample = pydub.AudioSegment.from_file(sample,
                                                        format=ext)
            self.samplepath = os.path.abspath(sample)
        elif isinstance(sample, pydub.AudioSegment):
            self._sample = sample
        else:
            raise WubWubError(&#39;sample must be a path or pydub.AudioSegment&#39;)

class MultiSampleTrack(Track):
    def __init__(self, name, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer, **kwargs)
        self.samples = {}

class Sampler(SingleSampleTrack, SamplerLikeTrack):
    def __init__(self, name, sample, sequencer, basepitch=&#39;C4&#39;, overlap=True):
        super().__init__(name=name, sample=sample, sequencer=sequencer,
                         basepitch=basepitch, overlap=overlap)
        self.overlap = overlap
        self.basepitch = basepitch

    def __repr__(self):
        return f&#39;Sampler(name=&#34;{self.name}&#34;)&#39;

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        sample = self.sample
        basepitch = self.basepitch
        next_position = np.inf
        for beat, value in sorted(self.notedict.items(), reverse=True):
            position = (beat-1) * b
            if isinstance(value, Note):
                note = value
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                next_position = position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=sample,
                                          position=position,
                                          duration=duration,
                                          basepitch=basepitch)
            elif isinstance(value, Chord):
                chord = value
                for note in chord.notes:
                    duration = note.length * b
                    if (position + duration) &gt; next_position and not self.overlap:
                        duration = next_position - position
                    audio = add_note_to_audio(note=note,
                                              audio=audio,
                                              sample=sample,
                                              position=position,
                                              duration=duration,
                                              basepitch=basepitch)
                next_position = position

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        test = self.sample
        if postprocess:
            test = self.postprocess(test)
        if duration is None:
            duration = len(test)
        else:
            duration = duration * SECOND
        play(test[:duration])

class MultiSampler(MultiSampleTrack, SamplerLikeTrack):
    def __init__(self, name, sequencer, overlap=True):
        super().__init__(name=name, sequencer=sequencer)
        self.overlap = overlap
        self.default_sample = pydub.AudioSegment.empty()

    def __repr__(self):
        return f&#39;MultiSampler(name=&#34;{self.name}&#34;)&#39;

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        next_position = np.inf
        for beat, value in sorted(self.notedict.items(), reverse=True):
            position = (beat-1) * b
            if isinstance(value, Note):
                note = value
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                next_position = position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=self.get_sample(note.pitch),
                                          position=position,
                                          duration=duration,
                                          shift=False)
            elif isinstance(value, Chord):
                chord = value
                for note in chord.notes:
                    duration = note.length * b
                    if (position + duration) &gt; next_position and not self.overlap:
                        duration = next_position - position
                    audio = add_note_to_audio(note=note,
                                              audio=audio,
                                              sample=self.get_sample(note.pitch),
                                              position=position,
                                              duration=duration,
                                              shift=False)
                next_position = position

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        for k, v in self.samples.items():
            test = v
            if postprocess:
                test = self.postprocess(test)
            if duration is None:
                duration = len(test)
            else:
                duration = duration * SECOND
            play(test[:duration])

    def add_sample(self, key, sample):
        if isinstance(sample, str):
            _, ext = os.path.splitext(sample)
            ext = ext.lower().strip(&#39;.&#39;)
            self.samples[key] = pydub.AudioSegment.from_file(sample,
                                                             format=ext)
        elif isinstance(sample, pydub.AudioSegment):
            self.samples[key] = sample
        else:
            raise WubWubError(&#39;sample must be a path or pydub.AudioSegment&#39;)

    def get_sample(self, key):
        return self.samples.get(key, self.default_sample)

class Arpeggiator(SingleSampleTrack):
    def __init__(self, name, sample, sequencer, basepitch=&#39;C4&#39;, freq=.5,
                 method=&#39;up&#39;):
        super().__init__(name=name, sample=sample, sequencer=sequencer,)
        self.freq = freq
        self.method = method
        self.basepitch = basepitch

    def __repr__(self):
        return (f&#39;Arpeggiator(name=&#34;{self.name}&#34;, &#39;
                f&#39;freq={self.freq}, method=&#34;{self.method}&#34;)&#39;)

    def make_chord(self, beat, pitches, length=1, merge=False):
        notes = [Note(p) for p in pitches]
        chord = ArpChord(notes, length)
        self.add(beat, chord, merge=merge,)

    def make_chord_every(self, freq, offset=0, pitches=0, length=1,
                         start=1, end=None, merge=False):
        notes = [Note(p) for p in pitches]
        chord = ArpChord(notes, length)
        b = start + offset
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            d[b] = chord
            b += freq
        self.add_fromdict(d, merge=merge)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        sample = self.sample
        basepitch = self.basepitch
        next_beat = np.inf
        for beat, chord in sorted(self.notedict.items(), reverse=True):
            try:
                length = chord.length
            except AttributeError:
                length = max(n.length for n in chord.notes)
            if beat + length &gt;= next_beat:
                length = next_beat - beat
            next_beat = beat
            arpeggiated = arpeggiate(chord, beat=beat, length=length,
                                     freq=self.freq, method=self.method)
            for arpbeat, note in arpeggiated.items():
                position = (arpbeat-1) * b
                duration = note.length * b
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=sample,
                                          position=position,
                                          duration=duration,
                                          basepitch=basepitch)

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        test = self.sample
        if postprocess:
            test = self.postprocess(test)
        if duration is None:
            duration = len(test)
        else:
            duration = duration * SECOND
        play(test[:duration])

    def unpack_notes(self, start=0, stop=np.inf,):
        unpacked = []
        for b, element in self.notedict.items():
            if not start &lt;= b &lt; stop:
                continue
            if isinstance(element, Note):
                unpacked.append((b, element))
            elif type(element) in [Chord, ArpChord]:
                arpeggiated = arpeggiate(element, beat=b,
                                         freq=self.freq, method=self.method)
                for k, v in arpeggiated.items():
                    unpacked.append((k, v))

        return unpacked</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wubwub.tracks.Arpeggiator"><code class="flex name class">
<span>class <span class="ident">Arpeggiator</span></span>
<span>(</span><span>name, sample, sequencer, basepitch='C4', freq=0.5, method='up')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arpeggiator(SingleSampleTrack):
    def __init__(self, name, sample, sequencer, basepitch=&#39;C4&#39;, freq=.5,
                 method=&#39;up&#39;):
        super().__init__(name=name, sample=sample, sequencer=sequencer,)
        self.freq = freq
        self.method = method
        self.basepitch = basepitch

    def __repr__(self):
        return (f&#39;Arpeggiator(name=&#34;{self.name}&#34;, &#39;
                f&#39;freq={self.freq}, method=&#34;{self.method}&#34;)&#39;)

    def make_chord(self, beat, pitches, length=1, merge=False):
        notes = [Note(p) for p in pitches]
        chord = ArpChord(notes, length)
        self.add(beat, chord, merge=merge,)

    def make_chord_every(self, freq, offset=0, pitches=0, length=1,
                         start=1, end=None, merge=False):
        notes = [Note(p) for p in pitches]
        chord = ArpChord(notes, length)
        b = start + offset
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            d[b] = chord
            b += freq
        self.add_fromdict(d, merge=merge)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        sample = self.sample
        basepitch = self.basepitch
        next_beat = np.inf
        for beat, chord in sorted(self.notedict.items(), reverse=True):
            try:
                length = chord.length
            except AttributeError:
                length = max(n.length for n in chord.notes)
            if beat + length &gt;= next_beat:
                length = next_beat - beat
            next_beat = beat
            arpeggiated = arpeggiate(chord, beat=beat, length=length,
                                     freq=self.freq, method=self.method)
            for arpbeat, note in arpeggiated.items():
                position = (arpbeat-1) * b
                duration = note.length * b
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=sample,
                                          position=position,
                                          duration=duration,
                                          basepitch=basepitch)

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        test = self.sample
        if postprocess:
            test = self.postprocess(test)
        if duration is None:
            duration = len(test)
        else:
            duration = duration * SECOND
        play(test[:duration])

    def unpack_notes(self, start=0, stop=np.inf,):
        unpacked = []
        for b, element in self.notedict.items():
            if not start &lt;= b &lt; stop:
                continue
            if isinstance(element, Note):
                unpacked.append((b, element))
            elif type(element) in [Chord, ArpChord]:
                arpeggiated = arpeggiate(element, beat=b,
                                         freq=self.freq, method=self.method)
                for k, v in arpeggiated.items():
                    unpacked.append((k, v))

        return unpacked</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.SingleSampleTrack" href="#wubwub.tracks.SingleSampleTrack">SingleSampleTrack</a></li>
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="wubwub.tracks.Arpeggiator.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.get_bpm()) * MINUTE
    overhang = _overhang_to_milli(overhang, overhang_type, b)
    tracklength = self.get_beats() * b + overhang
    audio = pydub.AudioSegment.silent(duration=tracklength)
    sample = self.sample
    basepitch = self.basepitch
    next_beat = np.inf
    for beat, chord in sorted(self.notedict.items(), reverse=True):
        try:
            length = chord.length
        except AttributeError:
            length = max(n.length for n in chord.notes)
        if beat + length &gt;= next_beat:
            length = next_beat - beat
        next_beat = beat
        arpeggiated = arpeggiate(chord, beat=beat, length=length,
                                 freq=self.freq, method=self.method)
        for arpbeat, note in arpeggiated.items():
            position = (arpbeat-1) * b
            duration = note.length * b
            audio = add_note_to_audio(note=note,
                                      audio=audio,
                                      sample=sample,
                                      position=position,
                                      duration=duration,
                                      basepitch=basepitch)

    return self.postprocess(audio)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Arpeggiator.make_chord"><code class="name flex">
<span>def <span class="ident">make_chord</span></span>(<span>self, beat, pitches, length=1, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_chord(self, beat, pitches, length=1, merge=False):
    notes = [Note(p) for p in pitches]
    chord = ArpChord(notes, length)
    self.add(beat, chord, merge=merge,)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Arpeggiator.make_chord_every"><code class="name flex">
<span>def <span class="ident">make_chord_every</span></span>(<span>self, freq, offset=0, pitches=0, length=1, start=1, end=None, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_chord_every(self, freq, offset=0, pitches=0, length=1,
                     start=1, end=None, merge=False):
    notes = [Note(p) for p in pitches]
    chord = ArpChord(notes, length)
    b = start + offset
    if end is None:
        end = self.get_beats() + 1
    d = {}
    while b &lt; end:
        d[b] = chord
        b += freq
    self.add_fromdict(d, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Arpeggiator.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, duration=None, postprocess=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soundtest(self, duration=None, postprocess=True,):
    test = self.sample
    if postprocess:
        test = self.postprocess(test)
    if duration is None:
        duration = len(test)
    else:
        duration = duration * SECOND
    play(test[:duration])</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Arpeggiator.unpack_notes"><code class="name flex">
<span>def <span class="ident">unpack_notes</span></span>(<span>self, start=0, stop=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack_notes(self, start=0, stop=np.inf,):
    unpacked = []
    for b, element in self.notedict.items():
        if not start &lt;= b &lt; stop:
            continue
        if isinstance(element, Note):
            unpacked.append((b, element))
        elif type(element) in [Chord, ArpChord]:
            arpeggiated = arpeggiate(element, beat=b,
                                     freq=self.freq, method=self.method)
            for k, v in arpeggiated.items():
                unpacked.append((k, v))

    return unpacked</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.tracks.MultiSampleTrack"><code class="flex name class">
<span>class <span class="ident">MultiSampleTrack</span></span>
<span>(</span><span>name, sequencer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiSampleTrack(Track):
    def __init__(self, name, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer, **kwargs)
        self.samples = {}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.MultiSampler" href="#wubwub.tracks.MultiSampler">MultiSampler</a></li>
</ul>
</dd>
<dt id="wubwub.tracks.MultiSampler"><code class="flex name class">
<span>class <span class="ident">MultiSampler</span></span>
<span>(</span><span>name, sequencer, overlap=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiSampler(MultiSampleTrack, SamplerLikeTrack):
    def __init__(self, name, sequencer, overlap=True):
        super().__init__(name=name, sequencer=sequencer)
        self.overlap = overlap
        self.default_sample = pydub.AudioSegment.empty()

    def __repr__(self):
        return f&#39;MultiSampler(name=&#34;{self.name}&#34;)&#39;

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        next_position = np.inf
        for beat, value in sorted(self.notedict.items(), reverse=True):
            position = (beat-1) * b
            if isinstance(value, Note):
                note = value
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                next_position = position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=self.get_sample(note.pitch),
                                          position=position,
                                          duration=duration,
                                          shift=False)
            elif isinstance(value, Chord):
                chord = value
                for note in chord.notes:
                    duration = note.length * b
                    if (position + duration) &gt; next_position and not self.overlap:
                        duration = next_position - position
                    audio = add_note_to_audio(note=note,
                                              audio=audio,
                                              sample=self.get_sample(note.pitch),
                                              position=position,
                                              duration=duration,
                                              shift=False)
                next_position = position

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        for k, v in self.samples.items():
            test = v
            if postprocess:
                test = self.postprocess(test)
            if duration is None:
                duration = len(test)
            else:
                duration = duration * SECOND
            play(test[:duration])

    def add_sample(self, key, sample):
        if isinstance(sample, str):
            _, ext = os.path.splitext(sample)
            ext = ext.lower().strip(&#39;.&#39;)
            self.samples[key] = pydub.AudioSegment.from_file(sample,
                                                             format=ext)
        elif isinstance(sample, pydub.AudioSegment):
            self.samples[key] = sample
        else:
            raise WubWubError(&#39;sample must be a path or pydub.AudioSegment&#39;)

    def get_sample(self, key):
        return self.samples.get(key, self.default_sample)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.MultiSampleTrack" href="#wubwub.tracks.MultiSampleTrack">MultiSampleTrack</a></li>
<li><a title="wubwub.tracks.SamplerLikeTrack" href="#wubwub.tracks.SamplerLikeTrack">SamplerLikeTrack</a></li>
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="wubwub.tracks.MultiSampler.add_sample"><code class="name flex">
<span>def <span class="ident">add_sample</span></span>(<span>self, key, sample)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sample(self, key, sample):
    if isinstance(sample, str):
        _, ext = os.path.splitext(sample)
        ext = ext.lower().strip(&#39;.&#39;)
        self.samples[key] = pydub.AudioSegment.from_file(sample,
                                                         format=ext)
    elif isinstance(sample, pydub.AudioSegment):
        self.samples[key] = sample
    else:
        raise WubWubError(&#39;sample must be a path or pydub.AudioSegment&#39;)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.MultiSampler.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.get_bpm()) * MINUTE
    overhang = _overhang_to_milli(overhang, overhang_type, b)
    tracklength = self.get_beats() * b + overhang
    audio = pydub.AudioSegment.silent(duration=tracklength)
    next_position = np.inf
    for beat, value in sorted(self.notedict.items(), reverse=True):
        position = (beat-1) * b
        if isinstance(value, Note):
            note = value
            duration = note.length * b
            if (position + duration) &gt; next_position and not self.overlap:
                duration = next_position - position
            next_position = position
            audio = add_note_to_audio(note=note,
                                      audio=audio,
                                      sample=self.get_sample(note.pitch),
                                      position=position,
                                      duration=duration,
                                      shift=False)
        elif isinstance(value, Chord):
            chord = value
            for note in chord.notes:
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=self.get_sample(note.pitch),
                                          position=position,
                                          duration=duration,
                                          shift=False)
            next_position = position

    return self.postprocess(audio)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.MultiSampler.get_sample"><code class="name flex">
<span>def <span class="ident">get_sample</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample(self, key):
    return self.samples.get(key, self.default_sample)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.MultiSampler.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, duration=None, postprocess=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soundtest(self, duration=None, postprocess=True,):
    for k, v in self.samples.items():
        test = v
        if postprocess:
            test = self.postprocess(test)
        if duration is None:
            duration = len(test)
        else:
            duration = duration * SECOND
        play(test[:duration])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.tracks.Sampler"><code class="flex name class">
<span>class <span class="ident">Sampler</span></span>
<span>(</span><span>name, sample, sequencer, basepitch='C4', overlap=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sampler(SingleSampleTrack, SamplerLikeTrack):
    def __init__(self, name, sample, sequencer, basepitch=&#39;C4&#39;, overlap=True):
        super().__init__(name=name, sample=sample, sequencer=sequencer,
                         basepitch=basepitch, overlap=overlap)
        self.overlap = overlap
        self.basepitch = basepitch

    def __repr__(self):
        return f&#39;Sampler(name=&#34;{self.name}&#34;)&#39;

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        overhang = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.get_beats() * b + overhang
        audio = pydub.AudioSegment.silent(duration=tracklength)
        sample = self.sample
        basepitch = self.basepitch
        next_position = np.inf
        for beat, value in sorted(self.notedict.items(), reverse=True):
            position = (beat-1) * b
            if isinstance(value, Note):
                note = value
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                next_position = position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=sample,
                                          position=position,
                                          duration=duration,
                                          basepitch=basepitch)
            elif isinstance(value, Chord):
                chord = value
                for note in chord.notes:
                    duration = note.length * b
                    if (position + duration) &gt; next_position and not self.overlap:
                        duration = next_position - position
                    audio = add_note_to_audio(note=note,
                                              audio=audio,
                                              sample=sample,
                                              position=position,
                                              duration=duration,
                                              basepitch=basepitch)
                next_position = position

        return self.postprocess(audio)

    def soundtest(self, duration=None, postprocess=True,):
        test = self.sample
        if postprocess:
            test = self.postprocess(test)
        if duration is None:
            duration = len(test)
        else:
            duration = duration * SECOND
        play(test[:duration])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.SingleSampleTrack" href="#wubwub.tracks.SingleSampleTrack">SingleSampleTrack</a></li>
<li><a title="wubwub.tracks.SamplerLikeTrack" href="#wubwub.tracks.SamplerLikeTrack">SamplerLikeTrack</a></li>
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="wubwub.tracks.Sampler.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.get_bpm()) * MINUTE
    overhang = _overhang_to_milli(overhang, overhang_type, b)
    tracklength = self.get_beats() * b + overhang
    audio = pydub.AudioSegment.silent(duration=tracklength)
    sample = self.sample
    basepitch = self.basepitch
    next_position = np.inf
    for beat, value in sorted(self.notedict.items(), reverse=True):
        position = (beat-1) * b
        if isinstance(value, Note):
            note = value
            duration = note.length * b
            if (position + duration) &gt; next_position and not self.overlap:
                duration = next_position - position
            next_position = position
            audio = add_note_to_audio(note=note,
                                      audio=audio,
                                      sample=sample,
                                      position=position,
                                      duration=duration,
                                      basepitch=basepitch)
        elif isinstance(value, Chord):
            chord = value
            for note in chord.notes:
                duration = note.length * b
                if (position + duration) &gt; next_position and not self.overlap:
                    duration = next_position - position
                audio = add_note_to_audio(note=note,
                                          audio=audio,
                                          sample=sample,
                                          position=position,
                                          duration=duration,
                                          basepitch=basepitch)
            next_position = position

    return self.postprocess(audio)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Sampler.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, duration=None, postprocess=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soundtest(self, duration=None, postprocess=True,):
    test = self.sample
    if postprocess:
        test = self.postprocess(test)
    if duration is None:
        duration = len(test)
    else:
        duration = duration * SECOND
    play(test[:duration])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.tracks.SamplerLikeTrack"><code class="flex name class">
<span>class <span class="ident">SamplerLikeTrack</span></span>
<span>(</span><span>name, sequencer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SamplerLikeTrack(Track):
    def __init__(self, name, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer)

    def make_notes(self, beats, pitches=0, lengths=1, volumes=0,
                   pitch_select=&#39;cycle&#39;, length_select=&#39;cycle&#39;,
                   volume_select=&#39;cycle&#39;, merge=False):

        if not isinstance(beats, Iterable):
            beats = [beats]

        pitches = self._convert_select_arg(pitches, pitch_select)
        lengths = self._convert_select_arg(lengths, length_select)
        volumes = self._convert_select_arg(volumes, volume_select)

        d = {b : Note(next(pitches), next(lengths), next(volumes))
             for b in beats}

        self.add_fromdict(d, merge=merge)

    def make_notes_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                         start=1, end=None, pitch_select=&#39;cycle&#39;,
                         length_select=&#39;cycle&#39;, volume_select=&#39;cycle&#39;, merge=False):

        freq = Fraction(freq).limit_denominator()

        pitches = self._convert_select_arg(pitches, pitch_select)
        lengths = self._convert_select_arg(lengths, length_select)
        volumes = self._convert_select_arg(volumes, volume_select)

        b = Fraction(start + offset).limit_denominator()
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            pos = b.numerator / b.denominator
            d[pos] = Note(next(pitches), next(lengths), next(volumes))
            b += freq

        self.add_fromdict(d, merge=merge)

    def make_chord(self, beat, pitches, lengths=1, volumes=0, merge=False):
        chord = self._make_chord_assemble(pitches, lengths, volumes)
        self.add(beat, chord, merge=merge)

    def make_chord_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                         start=1, end=None, merge=False):

        freq = Fraction(freq).limit_denominator()

        chord = self._make_chord_assemble(pitches, lengths, volumes)
        b = Fraction(start + offset).limit_denominator()
        if end is None:
            end = self.get_beats() + 1
        d = {}
        while b &lt; end:
            pos = b.numerator / b.denominator
            d[pos] = chord
            b += freq
        self.add_fromdict(d, merge=merge)

    def _make_chord_assemble(self, pitches, lengths, volumes):
        if not isinstance(pitches, Iterable) or isinstance(pitches, str):
            pitches = [pitches]

        if isinstance(lengths, Number):
            lengths = [lengths] * len(pitches)

        if isinstance(volumes, Number):
            volumes = [volumes] * len(pitches)

        notes = [Note(p, l, v) for p, l, v in zip(pitches, lengths, volumes)]
        return Chord(notes)

    def _convert_select_arg(self, arg, option):
        if not isinstance(arg, Iterable) or isinstance(arg, str):
            arg = [arg]

        if option == &#39;cycle&#39;:
            return itertools.cycle(arg)
        elif option == &#39;random&#39;:
            return random_choice_generator(arg)
        else:
            raise WubWubError(&#39;pitch, length, and volume select must be &#39;,
                              &#39;&#34;cycle&#34; or &#34;random&#34;.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.MultiSampler" href="#wubwub.tracks.MultiSampler">MultiSampler</a></li>
<li><a title="wubwub.tracks.Sampler" href="#wubwub.tracks.Sampler">Sampler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="wubwub.tracks.SamplerLikeTrack.make_chord"><code class="name flex">
<span>def <span class="ident">make_chord</span></span>(<span>self, beat, pitches, lengths=1, volumes=0, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_chord(self, beat, pitches, lengths=1, volumes=0, merge=False):
    chord = self._make_chord_assemble(pitches, lengths, volumes)
    self.add(beat, chord, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.SamplerLikeTrack.make_chord_every"><code class="name flex">
<span>def <span class="ident">make_chord_every</span></span>(<span>self, freq, offset=0, pitches=0, lengths=1, volumes=0, start=1, end=None, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_chord_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                     start=1, end=None, merge=False):

    freq = Fraction(freq).limit_denominator()

    chord = self._make_chord_assemble(pitches, lengths, volumes)
    b = Fraction(start + offset).limit_denominator()
    if end is None:
        end = self.get_beats() + 1
    d = {}
    while b &lt; end:
        pos = b.numerator / b.denominator
        d[pos] = chord
        b += freq
    self.add_fromdict(d, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.SamplerLikeTrack.make_notes"><code class="name flex">
<span>def <span class="ident">make_notes</span></span>(<span>self, beats, pitches=0, lengths=1, volumes=0, pitch_select='cycle', length_select='cycle', volume_select='cycle', merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_notes(self, beats, pitches=0, lengths=1, volumes=0,
               pitch_select=&#39;cycle&#39;, length_select=&#39;cycle&#39;,
               volume_select=&#39;cycle&#39;, merge=False):

    if not isinstance(beats, Iterable):
        beats = [beats]

    pitches = self._convert_select_arg(pitches, pitch_select)
    lengths = self._convert_select_arg(lengths, length_select)
    volumes = self._convert_select_arg(volumes, volume_select)

    d = {b : Note(next(pitches), next(lengths), next(volumes))
         for b in beats}

    self.add_fromdict(d, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.SamplerLikeTrack.make_notes_every"><code class="name flex">
<span>def <span class="ident">make_notes_every</span></span>(<span>self, freq, offset=0, pitches=0, lengths=1, volumes=0, start=1, end=None, pitch_select='cycle', length_select='cycle', volume_select='cycle', merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_notes_every(self, freq, offset=0, pitches=0, lengths=1, volumes=0,
                     start=1, end=None, pitch_select=&#39;cycle&#39;,
                     length_select=&#39;cycle&#39;, volume_select=&#39;cycle&#39;, merge=False):

    freq = Fraction(freq).limit_denominator()

    pitches = self._convert_select_arg(pitches, pitch_select)
    lengths = self._convert_select_arg(lengths, length_select)
    volumes = self._convert_select_arg(volumes, volume_select)

    b = Fraction(start + offset).limit_denominator()
    if end is None:
        end = self.get_beats() + 1
    d = {}
    while b &lt; end:
        pos = b.numerator / b.denominator
        d[pos] = Note(next(pitches), next(lengths), next(volumes))
        b += freq

    self.add_fromdict(d, merge=merge)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.tracks.SingleSampleTrack"><code class="flex name class">
<span>class <span class="ident">SingleSampleTrack</span></span>
<span>(</span><span>name, sample, sequencer, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleSampleTrack(Track):
    def __init__(self, name, sample, sequencer, **kwargs):
        super().__init__(name=name, sequencer=sequencer, **kwargs)
        self._sample = None
        self.sample = sample

    @property
    def sample(self):
        return self._sample

    @sample.setter
    def sample(self, sample):
        if isinstance(sample, str):
            _, ext = os.path.splitext(sample)
            ext = ext.lower().strip(&#39;.&#39;)
            self._sample = pydub.AudioSegment.from_file(sample,
                                                        format=ext)
            self.samplepath = os.path.abspath(sample)
        elif isinstance(sample, pydub.AudioSegment):
            self._sample = sample
        else:
            raise WubWubError(&#39;sample must be a path or pydub.AudioSegment&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.Arpeggiator" href="#wubwub.tracks.Arpeggiator">Arpeggiator</a></li>
<li><a title="wubwub.tracks.Sampler" href="#wubwub.tracks.Sampler">Sampler</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="wubwub.tracks.SingleSampleTrack.sample"><code class="name">var <span class="ident">sample</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sample(self):
    return self._sample</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="wubwub.tracks.SliceableDict"><code class="flex name class">
<span>class <span class="ident">SliceableDict</span></span>
<span>(</span><span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SliceableDict:
    def __init__(self, d):
        self.d = d

    def __getitem__(self, keys):
        if isinstance(keys, Number):
            return {keys: self.d[keys]}
        elif isinstance(keys, slice):
            start, stop = (keys.start, keys.stop)
            start = 0 if start is None else start
            stop = np.inf if stop is None else stop
            return {k:v for k, v in self.d.items()
                    if start &lt;= k &lt; stop}
        elif isinstance(keys, Iterable):
            if getattr(keys, &#39;dtype&#39;, False) == bool:
                if not len(keys) == len(self.d):
                    raise IndexError(f&#39;Length of boolean index ({len(keys)}) &#39;
                                     f&#34;does not match size of dict ({len(self)}).&#34;)
                return {k:v for boolean, (k, v) in
                        zip(keys, self.d.items()) if boolean}

            else:
                return {k: dict.get(self.d, k) for k in keys}
        else:
            raise IndexError(&#39;Could not interpret input as int, &#39;
                             &#39;slice, iterable, or boolean index.&#39;)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track"><code class="flex name class">
<span>class <span class="ident">Track</span></span>
<span>(</span><span>name, sequencer)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Track(metaclass=ABCMeta):

    handle_outside_notes = &#39;skip&#39;

    def __init__(self, name, sequencer,):
        self.notedict = SortedDict()
        self.samplepath = None

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._name = None
        self._sample = None
        self._sequencer = None
        self.sequencer = sequencer
        self.name = name

        self.plotting = {}

    def __getitem__(self, beat):
        if isinstance(beat, Number):
            return self.notedict[beat]
        elif isinstance(beat, slice):
            start, stop = (beat.start, beat.stop)
            start = 0 if start is None else start
            stop = np.inf if stop is None else stop
            return [self.notedict[k] for k in self.notedict.keys() if start &lt;= k &lt; stop]
        elif isinstance(beat, Iterable):
            if getattr(beat, &#39;dtype&#39;, False) == bool:
                if not len(beat) == len(self.notedict):
                    raise IndexError(f&#39;Length of boolean index ({len(beat)}) &#39;
                                     f&#34;does not match number of notes ({len(self.notedict)}).&#34;)
                return [self.notedict[k] for k, b in zip(self.notedict.keys(), beat)
                        if b]

            else:
                return [self.notedict[b] for b in beat]
        else:
            raise WubWubError(&#39;Index wubwub.Track with [beat], &#39;
                              &#39;[start:stop], or boolean index, &#39;
                              f&#39;not {type(beat)}&#39;)

    def __setitem__(self, beat, value):
        if isinstance(beat, Number):
            self.notedict[beat] = value
        elif isinstance(beat, slice):
            start, stop, step = (beat.start, beat.stop, beat.step)
            if step is None:
                # replace all notes in the range
                start = 0 if start is None else start
                stop = np.inf if stop is None else stop
                for k, v in self.notedict.items():
                    if k &lt; start:
                        continue
                    if k &gt;= stop:
                        break
                    self.notedict[k] = value
            else:
                # fill notes from start to stop every step
                start = 1 if start is None else start
                stop = self.get_beats() + 1 if stop is None else stop
                while start &lt; stop:
                    self.notedict[start] = value
                    start += step
        elif isinstance(beat, Iterable):
            if getattr(beat, &#39;dtype&#39;, False) == bool:
                if not len(beat) == len(self.notedict):
                    raise IndexError(f&#39;Length of boolean index ({len(beat)}) &#39;
                                     f&#34;does not match number of notes ({len(self.notedict)}).&#34;)
                if not type(value) in _notetypes_:
                    raise IndexError(&#39;Can only set with single note using &#39;
                                     &#39;boolean index.&#39;)
                for k, b in zip(self.notedict.keys(), beat):
                    if b:
                        self.notedict[k] = value
            else:
                if type(value) in _notetypes_:
                    value = [value] * len(beat)
                if len(beat) != len(value):
                    raise IndexError(f&#39;Length of new values ({len(value)}) &#39;
                                     &#39;does not equal length of indexer &#39;
                                     f&#39;({len(beat)}).&#39;)
                for b, v in zip(beat, value):
                    self.notedict[b] = v

        else:
            raise WubWubError(&#39;Index wubwub.Track with [beat], &#39;
                              &#39;[start:stop], or boolean index, &#39;
                              f&#39;not {type(beat)}&#39;)

    @property
    def slice(self):
        return SliceableDict(self.notedict)

    @property
    def sequencer(self):
        return self._sequencer

    @sequencer.setter
    def sequencer(self, sequencer):
        if sequencer == None:
            self._sequencer = None
            return

        if self._name in sequencer.tracknames():
            raise WubWubError(f&#39;name &#34;{self._name}&#34; already in use by new sequencer&#39;)

        if self._sequencer is not None:
            self._sequencer.delete_track(self)

        self._sequencer = sequencer
        self._sequencer._add_track(self)

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, new):
        if self.sequencer and new in self.sequencer.tracknames():
            raise WubWubError(f&#39;track name &#34;{new}&#34; already in use.&#39;)
        self._name = new

    def add(self, beat, element, merge=False, outsiders=None):

        if beat &gt;= self.get_beats() + 1:
            method = self.handle_outside_notes if outsiders is None else outsiders
            options = [&#39;skip&#39;, &#39;add&#39;, &#39;warn&#39;, &#39;raise&#39;]
            if method not in options:
                w = (&#39;`method` not recognized, &#39;
                     &#39;defaulting to &#34;skip&#34;.&#39;,)
                warnings.warn(w, WubWubWarning)
                method = &#39;skip&#39;
            if method == &#39;skip&#39;:
                return
            if method == &#39;warn&#39;:
                s = (&#34;Adding note on beat beyond the &#34;
                     &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                     &#34;in class docstring for `wb.Track` to toggle &#34;
                     &#34;this behavior.&#34;)
                warnings.warn(s, WubWubWarning)

            elif method == &#39;raise&#39;:
                s = (&#34;Tried to add note on beat beyond the &#34;
                     &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                     &#34;in class docstring for `wb.Track` to toggle &#34;
                     &#34;this behavior.&#34;)
                raise WubWubError(s)
        existing = self.notedict.get(beat, None)
        if existing and merge:
            element = existing + element
        self.notedict[beat] = element

    def add_fromdict(self, d, offset=0, outsiders=None, merge=False):
        for beat, element in d.items():

            self.add(beat=beat + offset, element=element, merge=merge,
                     outsiders=outsiders)

    def array_of_beats(self):
        return np.array(self.notedict.keys())

    def copy(self, newname=None, newseq=False, with_notes=True,):
        if newname is None:
            newname = self.name
        if newseq is False:
            newseq = self.sequencer
        new = copy.copy(self)
        for k, v in vars(new).items():
            if k == &#39;notedict&#39;:
                setattr(new, k, v.copy())
            elif k == &#39;_name&#39;:
                setattr(new, k, newname)
            elif k == &#39;_sequencer&#39;:
                setattr(new, k, None)
            else:
                setattr(new, k, copy.deepcopy(v))
        new.sequencer = newseq
        if not with_notes:
            new.delete_all()
        return new

    def copypaste(self, start, stop, newstart, outsiders=None, merge=False,):
        section = self.slice[start:stop]
        if section:
            offset = start - 1
            at_one = {k-offset:v for k, v in section.items()}
            self.add_fromdict(at_one, offset=newstart-1)

    def _handle_beats_dict_boolarray(self, beats):
        if getattr(beats, &#39;dtype&#39;, False) == bool:
            beats = self[beats].keys()
        elif isinstance(beats, dict):
            beats = beats.keys()
        elif isinstance(beats, Number):
            return [beats]
        return beats

    def quantize(self, resolution=1/4, merge=False):
        bts = self.get_beats()
        targets = np.empty(0)
        if isinstance(resolution, Number):
            resolution = [resolution]
        for r in resolution:
            if ((1 / r) % 1) != 0:
                raise WubWubError(&#39;`resolution` must evenly divide 1&#39;)
            steps = int(bts * (1 / r))
            beats = np.linspace(1, bts + 1, steps, endpoint=False)
            targets = np.append(targets, beats)
        targets = np.unique(targets)
        for b, note in self.notedict.copy().items():
            diffs = np.abs(targets - b)
            argmin = np.argmin(diffs)
            closest = targets[argmin]
            if b != closest:
                del self.notedict[b]
                self.add(closest, note, merge=merge)

    def shift(self, beats, by, merge=False):
        beats = self._handle_beats_dict_boolarray(beats)
        newkeys = [k + by if k in beats else k
                   for k in self.notedict.keys()]
        oldnotes = self.notedict.values()
        self.delete_all_notes()
        for newbeat, note in zip(newkeys, oldnotes):
            self.add(newbeat, note, merge=merge)

    def get_bpm(self):
        return self.sequencer.bpm

    def get_beats(self):
        return self.sequencer.beats

    def count_by_beat(self, res=1):
        out = defaultdict(int)
        res = 1/res
        for beat in self.array_of_beats():
            out[np.floor(beat * res) / res] += 1

        return dict(out)

    def pprint_notedict(self):
        pprint.pprint(self.notedict)

    def clean(self):
        maxi = self.get_beats()
        self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                    if 1 &lt;= b &lt; maxi +1})

    def delete_all(self):
        self.notedict = SortedDict({})

    def delete(self, beats):
        beats = self._handle_beats_dict_boolarray(beats)
        for beat in beats:
            del self.notedict[beat]

    def delete_fromrange(self, lo, hi):
        self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                    if not lo &lt;= b &lt; hi})

    def unpack_notes(self, start=0, stop=np.inf,):
        unpacked = []
        for b, element in self.notedict.items():
            if not start &lt;= b &lt; stop:
                continue
            if isinstance(element, Note):
                unpacked.append((b, element))
            elif type(element) in [Chord, ArpChord]:
                for note in element.notes:
                    unpacked.append((b, note))
        return unpacked

    @abstractmethod
    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        pass

    def postprocess(self, build):
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.get_bpm()) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    @abstractmethod
    def soundtest(self, duration=None, postprocess=True,):
        pass

    def plot(self, yaxis=&#39;semitones&#39;, timesig=4, grid=True, ax=None,
             plot_kwds=None, scatter_kwds=None):
        return trackplot(track=self,
                         yaxis=yaxis,
                         timesig=timesig,
                         grid=grid,
                         ax=ax,
                         plot_kwds=plot_kwds,
                         scatter_kwds=scatter_kwds)

    def pianoroll(self, timesig=4, grid=True,):
        return pianoroll(track=self, timesig=timesig, grid=grid)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="wubwub.tracks.MultiSampleTrack" href="#wubwub.tracks.MultiSampleTrack">MultiSampleTrack</a></li>
<li><a title="wubwub.tracks.SamplerLikeTrack" href="#wubwub.tracks.SamplerLikeTrack">SamplerLikeTrack</a></li>
<li><a title="wubwub.tracks.SingleSampleTrack" href="#wubwub.tracks.SingleSampleTrack">SingleSampleTrack</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="wubwub.tracks.Track.handle_outside_notes"><code class="name">var <span class="ident">handle_outside_notes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="wubwub.tracks.Track.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self._name</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.sequencer"><code class="name">var <span class="ident">sequencer</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sequencer(self):
    return self._sequencer</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.slice"><code class="name">var <span class="ident">slice</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def slice(self):
    return SliceableDict(self.notedict)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="wubwub.tracks.Track.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, beat, element, merge=False, outsiders=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, beat, element, merge=False, outsiders=None):

    if beat &gt;= self.get_beats() + 1:
        method = self.handle_outside_notes if outsiders is None else outsiders
        options = [&#39;skip&#39;, &#39;add&#39;, &#39;warn&#39;, &#39;raise&#39;]
        if method not in options:
            w = (&#39;`method` not recognized, &#39;
                 &#39;defaulting to &#34;skip&#34;.&#39;,)
            warnings.warn(w, WubWubWarning)
            method = &#39;skip&#39;
        if method == &#39;skip&#39;:
            return
        if method == &#39;warn&#39;:
            s = (&#34;Adding note on beat beyond the &#34;
                 &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                 &#34;in class docstring for `wb.Track` to toggle &#34;
                 &#34;this behavior.&#34;)
            warnings.warn(s, WubWubWarning)

        elif method == &#39;raise&#39;:
            s = (&#34;Tried to add note on beat beyond the &#34;
                 &#34;sequencer&#39;s length.  See `handle_outside_notes` &#34;
                 &#34;in class docstring for `wb.Track` to toggle &#34;
                 &#34;this behavior.&#34;)
            raise WubWubError(s)
    existing = self.notedict.get(beat, None)
    if existing and merge:
        element = existing + element
    self.notedict[beat] = element</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.add_fromdict"><code class="name flex">
<span>def <span class="ident">add_fromdict</span></span>(<span>self, d, offset=0, outsiders=None, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fromdict(self, d, offset=0, outsiders=None, merge=False):
    for beat, element in d.items():

        self.add(beat=beat + offset, element=element, merge=merge,
                 outsiders=outsiders)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.array_of_beats"><code class="name flex">
<span>def <span class="ident">array_of_beats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array_of_beats(self):
    return np.array(self.notedict.keys())</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    pass</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self):
    maxi = self.get_beats()
    self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                if 1 &lt;= b &lt; maxi +1})</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, newname=None, newseq=False, with_notes=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, newname=None, newseq=False, with_notes=True,):
    if newname is None:
        newname = self.name
    if newseq is False:
        newseq = self.sequencer
    new = copy.copy(self)
    for k, v in vars(new).items():
        if k == &#39;notedict&#39;:
            setattr(new, k, v.copy())
        elif k == &#39;_name&#39;:
            setattr(new, k, newname)
        elif k == &#39;_sequencer&#39;:
            setattr(new, k, None)
        else:
            setattr(new, k, copy.deepcopy(v))
    new.sequencer = newseq
    if not with_notes:
        new.delete_all()
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.copypaste"><code class="name flex">
<span>def <span class="ident">copypaste</span></span>(<span>self, start, stop, newstart, outsiders=None, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copypaste(self, start, stop, newstart, outsiders=None, merge=False,):
    section = self.slice[start:stop]
    if section:
        offset = start - 1
        at_one = {k-offset:v for k, v in section.items()}
        self.add_fromdict(at_one, offset=newstart-1)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.count_by_beat"><code class="name flex">
<span>def <span class="ident">count_by_beat</span></span>(<span>self, res=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count_by_beat(self, res=1):
    out = defaultdict(int)
    res = 1/res
    for beat in self.array_of_beats():
        out[np.floor(beat * res) / res] += 1

    return dict(out)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, beats)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, beats):
    beats = self._handle_beats_dict_boolarray(beats)
    for beat in beats:
        del self.notedict[beat]</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.delete_all"><code class="name flex">
<span>def <span class="ident">delete_all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_all(self):
    self.notedict = SortedDict({})</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.delete_fromrange"><code class="name flex">
<span>def <span class="ident">delete_fromrange</span></span>(<span>self, lo, hi)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_fromrange(self, lo, hi):
    self.notedict = SortedDict({b:note for b, note in self.notedict.items()
                                if not lo &lt;= b &lt; hi})</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.get_beats"><code class="name flex">
<span>def <span class="ident">get_beats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_beats(self):
    return self.sequencer.beats</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.get_bpm"><code class="name flex">
<span>def <span class="ident">get_bpm</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bpm(self):
    return self.sequencer.bpm</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.pianoroll"><code class="name flex">
<span>def <span class="ident">pianoroll</span></span>(<span>self, timesig=4, grid=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pianoroll(self, timesig=4, grid=True,):
    return pianoroll(track=self, timesig=timesig, grid=grid)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, start=1, end=None, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.get_bpm()) * MINUTE
    start = (start-1) * b
    if end is not None:
        end = (end-1) * b
    build = self.build(overhang, overhang_type)
    play(build[start:end])</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, yaxis='semitones', timesig=4, grid=True, ax=None, plot_kwds=None, scatter_kwds=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, yaxis=&#39;semitones&#39;, timesig=4, grid=True, ax=None,
         plot_kwds=None, scatter_kwds=None):
    return trackplot(track=self,
                     yaxis=yaxis,
                     timesig=timesig,
                     grid=grid,
                     ax=ax,
                     plot_kwds=plot_kwds,
                     scatter_kwds=scatter_kwds)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.postprocess"><code class="name flex">
<span>def <span class="ident">postprocess</span></span>(<span>self, build)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocess(self, build):
    for step in self.postprocess_steps:
        if step == &#39;effects&#39;:
            build = add_effects(build, self.effects)
        if step == &#39;volume&#39;:
            build += self.volume
        if step == &#39;pan&#39;:
            build = build.pan(self.pan)
    return build</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.pprint_notedict"><code class="name flex">
<span>def <span class="ident">pprint_notedict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pprint_notedict(self):
    pprint.pprint(self.notedict)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.quantize"><code class="name flex">
<span>def <span class="ident">quantize</span></span>(<span>self, resolution=0.25, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quantize(self, resolution=1/4, merge=False):
    bts = self.get_beats()
    targets = np.empty(0)
    if isinstance(resolution, Number):
        resolution = [resolution]
    for r in resolution:
        if ((1 / r) % 1) != 0:
            raise WubWubError(&#39;`resolution` must evenly divide 1&#39;)
        steps = int(bts * (1 / r))
        beats = np.linspace(1, bts + 1, steps, endpoint=False)
        targets = np.append(targets, beats)
    targets = np.unique(targets)
    for b, note in self.notedict.copy().items():
        diffs = np.abs(targets - b)
        argmin = np.argmin(diffs)
        closest = targets[argmin]
        if b != closest:
            del self.notedict[b]
            self.add(closest, note, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.shift"><code class="name flex">
<span>def <span class="ident">shift</span></span>(<span>self, beats, by, merge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift(self, beats, by, merge=False):
    beats = self._handle_beats_dict_boolarray(beats)
    newkeys = [k + by if k in beats else k
               for k in self.notedict.keys()]
    oldnotes = self.notedict.values()
    self.delete_all_notes()
    for newbeat, note in zip(newkeys, oldnotes):
        self.add(newbeat, note, merge=merge)</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, duration=None, postprocess=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def soundtest(self, duration=None, postprocess=True,):
    pass</code></pre>
</details>
</dd>
<dt id="wubwub.tracks.Track.unpack_notes"><code class="name flex">
<span>def <span class="ident">unpack_notes</span></span>(<span>self, start=0, stop=inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unpack_notes(self, start=0, stop=np.inf,):
    unpacked = []
    for b, element in self.notedict.items():
        if not start &lt;= b &lt; stop:
            continue
        if isinstance(element, Note):
            unpacked.append((b, element))
        elif type(element) in [Chord, ArpChord]:
            for note in element.notes:
                unpacked.append((b, note))
    return unpacked</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="wubwub Home" href="https://github.com/earnestt1234/wubwub/">
<img src="https://raw.githubusercontent.com/earnestt1234/wubwub/main/img/logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wubwub" href="index.html">wubwub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wubwub.tracks.Arpeggiator" href="#wubwub.tracks.Arpeggiator">Arpeggiator</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.Arpeggiator.build" href="#wubwub.tracks.Arpeggiator.build">build</a></code></li>
<li><code><a title="wubwub.tracks.Arpeggiator.make_chord" href="#wubwub.tracks.Arpeggiator.make_chord">make_chord</a></code></li>
<li><code><a title="wubwub.tracks.Arpeggiator.make_chord_every" href="#wubwub.tracks.Arpeggiator.make_chord_every">make_chord_every</a></code></li>
<li><code><a title="wubwub.tracks.Arpeggiator.soundtest" href="#wubwub.tracks.Arpeggiator.soundtest">soundtest</a></code></li>
<li><code><a title="wubwub.tracks.Arpeggiator.unpack_notes" href="#wubwub.tracks.Arpeggiator.unpack_notes">unpack_notes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.tracks.MultiSampleTrack" href="#wubwub.tracks.MultiSampleTrack">MultiSampleTrack</a></code></h4>
</li>
<li>
<h4><code><a title="wubwub.tracks.MultiSampler" href="#wubwub.tracks.MultiSampler">MultiSampler</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.MultiSampler.add_sample" href="#wubwub.tracks.MultiSampler.add_sample">add_sample</a></code></li>
<li><code><a title="wubwub.tracks.MultiSampler.build" href="#wubwub.tracks.MultiSampler.build">build</a></code></li>
<li><code><a title="wubwub.tracks.MultiSampler.get_sample" href="#wubwub.tracks.MultiSampler.get_sample">get_sample</a></code></li>
<li><code><a title="wubwub.tracks.MultiSampler.soundtest" href="#wubwub.tracks.MultiSampler.soundtest">soundtest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.tracks.Sampler" href="#wubwub.tracks.Sampler">Sampler</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.Sampler.build" href="#wubwub.tracks.Sampler.build">build</a></code></li>
<li><code><a title="wubwub.tracks.Sampler.soundtest" href="#wubwub.tracks.Sampler.soundtest">soundtest</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.tracks.SamplerLikeTrack" href="#wubwub.tracks.SamplerLikeTrack">SamplerLikeTrack</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.SamplerLikeTrack.make_chord" href="#wubwub.tracks.SamplerLikeTrack.make_chord">make_chord</a></code></li>
<li><code><a title="wubwub.tracks.SamplerLikeTrack.make_chord_every" href="#wubwub.tracks.SamplerLikeTrack.make_chord_every">make_chord_every</a></code></li>
<li><code><a title="wubwub.tracks.SamplerLikeTrack.make_notes" href="#wubwub.tracks.SamplerLikeTrack.make_notes">make_notes</a></code></li>
<li><code><a title="wubwub.tracks.SamplerLikeTrack.make_notes_every" href="#wubwub.tracks.SamplerLikeTrack.make_notes_every">make_notes_every</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.tracks.SingleSampleTrack" href="#wubwub.tracks.SingleSampleTrack">SingleSampleTrack</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.SingleSampleTrack.sample" href="#wubwub.tracks.SingleSampleTrack.sample">sample</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="wubwub.tracks.SliceableDict" href="#wubwub.tracks.SliceableDict">SliceableDict</a></code></h4>
</li>
<li>
<h4><code><a title="wubwub.tracks.Track" href="#wubwub.tracks.Track">Track</a></code></h4>
<ul class="">
<li><code><a title="wubwub.tracks.Track.add" href="#wubwub.tracks.Track.add">add</a></code></li>
<li><code><a title="wubwub.tracks.Track.add_fromdict" href="#wubwub.tracks.Track.add_fromdict">add_fromdict</a></code></li>
<li><code><a title="wubwub.tracks.Track.array_of_beats" href="#wubwub.tracks.Track.array_of_beats">array_of_beats</a></code></li>
<li><code><a title="wubwub.tracks.Track.build" href="#wubwub.tracks.Track.build">build</a></code></li>
<li><code><a title="wubwub.tracks.Track.clean" href="#wubwub.tracks.Track.clean">clean</a></code></li>
<li><code><a title="wubwub.tracks.Track.copy" href="#wubwub.tracks.Track.copy">copy</a></code></li>
<li><code><a title="wubwub.tracks.Track.copypaste" href="#wubwub.tracks.Track.copypaste">copypaste</a></code></li>
<li><code><a title="wubwub.tracks.Track.count_by_beat" href="#wubwub.tracks.Track.count_by_beat">count_by_beat</a></code></li>
<li><code><a title="wubwub.tracks.Track.delete" href="#wubwub.tracks.Track.delete">delete</a></code></li>
<li><code><a title="wubwub.tracks.Track.delete_all" href="#wubwub.tracks.Track.delete_all">delete_all</a></code></li>
<li><code><a title="wubwub.tracks.Track.delete_fromrange" href="#wubwub.tracks.Track.delete_fromrange">delete_fromrange</a></code></li>
<li><code><a title="wubwub.tracks.Track.get_beats" href="#wubwub.tracks.Track.get_beats">get_beats</a></code></li>
<li><code><a title="wubwub.tracks.Track.get_bpm" href="#wubwub.tracks.Track.get_bpm">get_bpm</a></code></li>
<li><code><a title="wubwub.tracks.Track.handle_outside_notes" href="#wubwub.tracks.Track.handle_outside_notes">handle_outside_notes</a></code></li>
<li><code><a title="wubwub.tracks.Track.name" href="#wubwub.tracks.Track.name">name</a></code></li>
<li><code><a title="wubwub.tracks.Track.pianoroll" href="#wubwub.tracks.Track.pianoroll">pianoroll</a></code></li>
<li><code><a title="wubwub.tracks.Track.play" href="#wubwub.tracks.Track.play">play</a></code></li>
<li><code><a title="wubwub.tracks.Track.plot" href="#wubwub.tracks.Track.plot">plot</a></code></li>
<li><code><a title="wubwub.tracks.Track.postprocess" href="#wubwub.tracks.Track.postprocess">postprocess</a></code></li>
<li><code><a title="wubwub.tracks.Track.pprint_notedict" href="#wubwub.tracks.Track.pprint_notedict">pprint_notedict</a></code></li>
<li><code><a title="wubwub.tracks.Track.quantize" href="#wubwub.tracks.Track.quantize">quantize</a></code></li>
<li><code><a title="wubwub.tracks.Track.sequencer" href="#wubwub.tracks.Track.sequencer">sequencer</a></code></li>
<li><code><a title="wubwub.tracks.Track.shift" href="#wubwub.tracks.Track.shift">shift</a></code></li>
<li><code><a title="wubwub.tracks.Track.slice" href="#wubwub.tracks.Track.slice">slice</a></code></li>
<li><code><a title="wubwub.tracks.Track.soundtest" href="#wubwub.tracks.Track.soundtest">soundtest</a></code></li>
<li><code><a title="wubwub.tracks.Track.unpack_notes" href="#wubwub.tracks.Track.unpack_notes">unpack_notes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>