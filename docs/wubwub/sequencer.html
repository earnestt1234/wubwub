<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>wubwub.sequencer API documentation</title>
<meta name="description" content="This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wubwub.sequencer</code></h1>
</header>
<section id="section-intro">
<p>This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub.
&#34;&#34;&#34;

import os
import time

import pydub

from wubwub.audio import add_effects, play, _overhang_to_milli
from wubwub.errors import WubWubError
from wubwub.plots import sequencerplot
from wubwub.resources import MINUTE, unique_name
from wubwub.seqstring import seqstring
from wubwub.tracks import Sampler, Arpeggiator, MultiSampler

__all__ = [&#39;Sequencer&#39;, &#39;stitch&#39;, &#39;join&#39;, &#39;loop&#39;]

class Sequencer:
    &#39;&#39;&#39;
    The Sequencer is the main tool for creating beats in wubwub.  Sequencers
    hold and organize individual instrument Tracks which can be filled
    with musical elements.  Sequencers have a defined length (and tempo), but
    multiple can be combined to create longer/varied arrangements.

    Both parameters for initialization (BPM and length) can be tweaked
    after creation by setting the value of the &lt;code&gt;bpm&lt;/code&gt; or
    &lt;code&gt;beats&lt;/code&gt; attributes.

    Parameters
    ----------
    bpm : int or float
        Tempo of the sequencer (beats per minute).
    beats : int
        The length of the sequence, in beats.

    Examples
    --------
    Initialize a Sequencer with a tempo and length:

    ```python
    &gt;&gt;&gt; import wubwub as wb
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq
    Sequencer(bpm=120, beats=8, tracks=0)

    ```
    &#39;&#39;&#39;

    def __init__(self, bpm, beats):
        &#34;&#34;&#34;Initialization function for the Sequencer.  Sets the BPM and beats
        based on user input, also defaults attributes related to post-processing
        the output audio and creates a container for subsidiary tracks.&#34;&#34;&#34;

        self.bpm = bpm
        self.beats = beats

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._tracks = []

    def __repr__(self):
        &#34;&#34;&#34;String representation of self.&#34;&#34;&#34;
        l = len(self.tracks())
        return f&#34;Sequencer(bpm={self.bpm}, beats={self.beats}, tracks={l})&#34;

    def __getitem__(self, name):
        &#34;&#34;&#34;Allows for retrieval of Track objects by their string name.&#34;&#34;&#34;
        if not isinstance(name, str):
            e = f&#39;Can only index Sequencer with str, not {type(name)}&#39;
            raise WubWubError(e)
        return self.get_track(name)

    def _add_track(self, track):
        &#34;&#34;&#34;Helper function called when adding a new track to self.  Checks for
        duplicate names, and tries to ensure non-duplicate entries of items
        in different Sequencers.&#34;&#34;&#34;
        if track.name in self.tracknames():
            raise WubWubError(f&#39;Track name &#34;{track.name}&#34; already in use.&#39;)
        if track.sequencer != self:
            track.sequencer = self
        if track not in self._tracks:
            self._tracks.append(track)

    def copypaste_section(self, start, stop, newstart):
        &#39;&#39;&#39;
        For all tracks of the Sequencer, take a section of notes and replicate
        them on a new beat (keeping the same relative spacing between notes).
        Simply, this method calls `wubwub.tracks.Track.copypaste()`
        for all tracks within the Sequencer.

        Parameters
        ----------
        start : int or float
            Beat to start copying notes (inclusive).
        stop : int or float
            Beat to stop copying notes (exlcusive).
        newstart : int or float
            Beat to paste the copied section.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for track in self.tracks():
            track.copypaste(start, stop, newstart)

    def set_beats_and_clean(self, new):
        &#34;&#34;&#34;
        Modifies the Sequencer length while simultaneously removing notes
        that are outside of the sequence after the change.  I.e., sets
        &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks.Track.clean()` for
        all tracks.  This is a convenience method which is only useful when
        shortening the sequence length.

        Parameters
        ----------
        new : int
            New value for the length of the Sequencer.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.beats = new
        for track in self.tracks():
            track.clean()

    def get_track(self, track):
        &#39;&#39;&#39;
        Return a Track, keyed by either its name or the Track
        itself (provided the Track is part of the current Sequencer).

        Parameters
        ----------
        track : str or Track
            Handle for a Track to retrieve.

        Raises
        ------
        ValueError
            Track not found.

        Returns
        -------
        Track
            A track that is part of this Sequencer.

        &#39;&#39;&#39;
        if isinstance(track, str):
            try:
                return next(t for t in self._tracks if t.name == track)
            except:
                raise ValueError(f&#39;no track with name {track}&#39;)
        elif track in self._tracks:
            return track
        else:
            raise ValueError(&#39;Requested track is not part of sequencer.&#39;)

    def tracks(self):
        &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
        return tuple(self._tracks)

    def tracknames(self):
        &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
        return [t.name for t in self._tracks]

    def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
        &#34;&#34;&#34;
        Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Sampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Returns
        -------
        new : wubwub.tracks.Sampler
            The new Track.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound
        seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

        # using a pydub.AudioSegment
        import wubwub.sounds as snd

        clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
        seq.add_sampler(clap, name=&#39;clap&#39;)
        ```

        &#34;&#34;&#34;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Sampler(name=name, sample=sample, overlap=overlap,
                      basepitch=basepitch, sequencer=self)
        return new

    def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                        basepitch=&#39;C4&#39;):
        &#39;&#39;&#39;
        Create a new `wubwub.tracks.Arpeggiator` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Arpeggiator`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        freq : int or float, optional
            Set the frequency of the new arpeggiator. The default is 0.5.
        method : str, optional
            Set the pattern of the new arpeggiator. The default is &#39;up&#39;.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Returns
        -------
        new : wubwub.tracks.Arpeggiator
            The new Track.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound, or a pydub.AudioSegment
        seq.add_arpeggiator(&#39;saw.wav&#39;, name=&#39;Arp&#39;, freq=.5, method=&#39;downup&#39;)
        ```

        &#39;&#39;&#39;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Arpeggiator(name=name, sample=sample, freq=freq,
                          method=method, basepitch=basepitch,
                          sequencer=self)
        return new

    def add_multisampler(self, name=None, overlap=False):
        &#39;&#39;&#39;
        Create a new `wubwub.tracks.MultiSampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.MultiSampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.

        Returns
        -------
        new : wubwub.tracks.MultiSampler
            The new Track.

        &#39;&#39;&#39;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = MultiSampler(name=name, overlap=overlap, sequencer=self)
        return new

    def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
        &#39;&#39;&#39;
        From a list of sounds or pydub Audio Segments, add multiple
        `wubwub.tracks.Sampler` Tracks.

        Parameters
        ----------
        samples : list like
            List of paths to sounds, or pydub AudioSegments to load.
        names : list like, optional
            The string name of each sample being added. The default is None.
        overlap : bool, optional
            The overlap behavior of the new samplers. The default is False.
        basepitch : int or str, optional
            The base pitch of the new samplers. The default is &#39;C4&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        if names is None:
            names = [None] * len(samples)
        for sample, name in zip(samples, names):
            self.add_sampler(sample=sample, name=name, overlap=overlap,
                             basepitch=basepitch)

    def duplicate_track(self, track, newname=None, with_notes=True):
        &#39;&#39;&#39;
        Create a copy of the specified Track within and add it to the
        current Sequencer.

        Parameters
        ----------
        track : wubwub.tracks.Track or str
            Name of a Track, or the actual Track object.
        newname : str, optional
            New name for the duplicated Track. The default is None.  If not passed,
            a generic name is created.
        with_notes : bool, optional
            When True (default), all the Notes/Chords contained in the original
            Track are copied over.

        Returns
        -------
        dup : wubwub.tracks.Track
            Reference to the new Track.

        Examples
        --------

        ```python
        &gt;&gt;&gt; import wubwub as wb

        # add a track with some notes
        &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
        &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)
        &gt;&gt;&gt; seq[&#39;kick1&#39;].make_notes_every(1)

        # duplicate the track
        &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick2&#39;)

        # by default, the notes are copied
        &gt;&gt;&gt; len(seq[&#39;kick2&#39;].notedict)
        8

        # specify with_notes to change this behavior
        &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick3&#39;, with_notes=False)
        &gt;&gt;&gt; len(seq[&#39;kick3&#39;].notedict)
        0
        ```

        &#39;&#39;&#39;
        if newname is None:
            newname = unique_name(&#39;Track&#39;, self.tracknames())
        dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
        return dup

    def copy(self, with_notes=True):
        &#39;&#39;&#39;
        Create a copy of the current Sequencer.  The copy (and its associated
        Tracks) are *new objects*, so editing it will not affect this Sequencer
        (and vice versa).


        Parameters
        ----------
        with_notes : bool, optional
            When True (default), all the Notes/Chords are copied over for
            every copied track.

        Returns
        -------
        new : wubwub.sequencer.Sequencer
            The new Sequencer.

        Examples
        --------

        ```python
        &gt;&gt;&gt; import wubwub as wb

        # add a track
        &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
        &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)

        # copy the sequencer
        &gt;&gt;&gt; other = seq.copy()

        # editing the new sequencer doesn&#39;t affect the original
        &gt;&gt;&gt; other.delete_track(&#39;kick1&#39;)
        &gt;&gt;&gt; other.tracknames()
        []

        &gt;&gt;&gt; seq.tracknames()
        [&#39;kick1&#39;]
        ```

        &#39;&#39;&#39;
        new = Sequencer(beats=self.beats, bpm=self.bpm)
        for track in self.tracks():
            track.copy(with_notes=with_notes, newseq=new)
        return new

    def split(self, beat):
        &#39;&#39;&#39;
        Split the Sequencer into two new Sequencers at a given beat.  The objects
        returned are *new Sequencers* (generated by `Sequencer.copy()`).

        Parameters
        ----------
        beat : int
            The beat to split the Sequencer on.

        Raises
        ------
        TypeError
            Non-integer beat is passed.

        Returns
        -------
        a, b : wubwub.sequencer.Sequencer
            Two new Sequencers.

        Examples
        --------
        ```python
        &gt;&gt;&gt; import wubwub as wb
        &gt;&gt;&gt; import wubwub.sounds as snd

        # make a sequencer and add tracks/notes
        &gt;&gt;&gt; seq = wb.Sequencer(beats=8, bpm=100)
        &gt;&gt;&gt; drums = snd.load(&#39;drums.808&#39;)
        &gt;&gt;&gt; kick = seq.add_sampler(drums[&#39;kick1&#39;], name=&#39;kick&#39;)
        &gt;&gt;&gt; snare = seq.add_sampler(drums[&#39;snare&#39;], name=&#39;snare&#39;)
        &gt;&gt;&gt; kick.make_notes_every(2)
        &gt;&gt;&gt; snare.make_notes_every(2, offset=1)
        &gt;&gt;&gt; seq.show()
              1 2 3 4 5 6 7 8
         kick ■ □ ■ □ ■ □ ■ □
        snare □ ■ □ ■ □ ■ □ ■

        # split
        &gt;&gt;&gt; a, b = seq.split(4)

        # show
        &gt;&gt;&gt; a.show()
              1 2 3
         kick ■ □ ■
        snare □ ■ □

        &gt;&gt;&gt; b.show()
              1 2 3 4 5
         kick □ ■ □ ■ □
        snare ■ □ ■ □ ■
        ```

        &#39;&#39;&#39;
        if not isinstance(beat, int):
            raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

        a1, a2 = (1, beat)
        b1, b2 = (beat, self.beats+1)

        a = self.copy(with_notes=False)
        a.beats = a2 - a1
        b = self.copy(with_notes=False)
        b.beats = b2 - b1

        for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
            anotes = selftrack.slice[a1:a2]
            atrack.add_fromdict(anotes)
            bnotes = selftrack.slice[b1:b2]
            btrack.add_fromdict(bnotes, offset=(-beat + 1))

        return a, b

    def delete_track(self, track):
        &#34;&#34;&#34;
        Delete a Track from the Sequencer, along with any entered Notes.

        Parameters
        ----------
        track : str or wubwub.tracks.Track
            Reference to the Track to delete.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        t = self.get_track(track)
        t.sequencer = None
        self._tracks.remove(t)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Render all the contained Tracks into one output, namely a pydub
        AudioSegment.  Calls the &#34;build&#34; method of each Track, and overlays
        them.

        Parameters
        ----------
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        pydub.AudioSegment
            The rendered audio.

        Examples
        --------
        ```python
        &gt;&gt;&gt; import wubwub as wb

        # 60 BPM == 1 second per beat
        &gt;&gt;&gt; seq = wb.Sequencer(beats=4, bpm=60)

        # expected length (in milliseconds, per pydub)
        &gt;&gt;&gt; expected = 4 * 1000
        &gt;&gt;&gt; expected == len(seq.build())
        True

        # add overhang of 2 beats
        &gt;&gt;&gt; len(seq.build(overhang=2))
        6000

        # add overhang in seconds
        &gt;&gt;&gt; len(seq.build(overhang=3.777, overhang_type=&#39;beats&#39;))
        7777
        ```

        &#39;&#39;&#39;
        b = (1/self.bpm) * MINUTE
        seq_oh = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.beats * b + seq_oh
        audio = pydub.AudioSegment.silent(duration=tracklength)
        for track in self.tracks():
            audio = audio.overlay(track.build(overhang, overhang_type))
        return self.postprocess(audio)

    def postprocess(self, build):
        &#39;&#39;&#39;
        Add postprocessing to a rendered audio output of the Sequencer,
        typically that of `Sequencer.build()`.  There are currently 3
        postprocessing steps applied, corresponding to 3 attributes of
        the Sequencer:

        - `effects`: This attribute can be set to a pysndfx
        AudioEffectsChain instance to add audio effects (such as reverb,
        delay, overdrive, etc.) See
        [here](https://github.com/carlthome/python-audio-effects) for more
        documentation.
        - `volume`: This attribute can be set to modify the output volume
        of the build.  Note that the value reflects a relative change in
        dB, so values can be positive or negative.
        - `pan`: a value between `-1.0` (100% left) and `+1.0` (100% right)
        indicating the stereo panning (`0.0` is centered).

        The order/presence of these processing steps can be determined by
        setting the `postprocess_steps` attribute, which should be a list
        containing some subset of the strings `&#39;effects&#39;`, `&#39;volume&#39;`, and
        `&#39;pan`&#39; (corresponding to each of the three steps above).  The default
        is `self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]`.  *Omitted
        steps in this attribute will not be applied, while repeated steps
        will be applied multiple times.*  Additionally, the steps are applied
        in the order encountered in `self.postprocess_steps`.

        Parameters
        ----------
        build : pydub AudioSegment
            Audio to postprocess, typically output of `Sequencer.build()`

        Returns
        -------
        build : pydub AudioSegment
            Audio with postprocessing steps applied.

        &#39;&#39;&#39;
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Audio playback of the Sequencer.

        Parameters
        ----------
        start : int, optional
            Beat to start playback on. The default is 1.
        end : int or None, optional
            Beat to end playback on. The default is None.
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        b = (1/self.bpm) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Return a looped rendering of the Sequencer.  This is akin to
        `Sequencer.build()`, but the content of the Sequencer is repeated
        a specified number of times.

        Parameters
        ----------
        times : int, optional
            How many times to loop. The default is 4.
        internal_overhang : int or float, optional
            Determine the length of extra time to render when the loop restarts.
            This can be used to prevent abrubt shortening of sounds near the
            end of the sequence. The default is 0, meaning all sounds are
            cut at the end of the Sequencer length for each loop.
        end_overhang : int or float, optional
            Determine the length of extra time to render at the of the audio,
            i.e. after all loops are complete. The default is 0.
        overhang_type : str -&gt; &#39;beats&#39; or &#39;seconds&#39;, optional
            Units for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        looped : pydub.AudioSegment
            The looped audio.

        &#39;&#39;&#39;
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        return looped

    def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;Calls `Sequencer.play()` on `Sequencer.loop()`; i.e.
        immediately plays back looped audio.&#39;&#39;&#39;
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        play(looped)

    def soundtest(self, selection=None, postprocess=True, gap=.5):
        &#39;&#39;&#39;Calls the sound test method for each Track in the Sequencer; i.e.
        plays back all the samples being used.&#39;&#39;&#39;
        if selection is None:
            selection = self.tracks()
        else:
            selection = [self.get_track(i) for i in selection]

        for track in selection:
            print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
            time.sleep(.25)
            track.soundtest(postprocess=postprocess)
            time.sleep(gap)

    def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Saves the rendered audio to a file.  The Sequencer creates
        a pydub AudioSegment which contains all Tracks overlaid,
        and then uses its export method to save.

        See the pydub documentation for more information on exporting.

        Parameters
        ----------
        path : system path
            File path to save the audio to.
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        _, fmt = os.path.splitext(path)
        build = self.build(overhang, overhang_type)
        build.export(path, format=fmt)

    def show(self, printout=True, name_cutoff=None, resolution=1,
             singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
        &#39;&#39;&#39;
        Print (or return) a sequencer grid diagram, showing when
        each Track contains notes.  For more information, see
        `wubwub.seqstring.seqstring()`.

        Parameters
        ----------
        printout : bool, optional
            When True (default), print the diagram.  When False,
            return the string.
        name_cutoff : int, optional
            Number of characters to allow track names to be. The default is None.
        resolution : int or float, optional
            Determines the frequency of beats to use. The default is 1.
        singlenote : str, optional
            Character to use for beats containing single Notes. The default is &#39;■&#39;.
        multinote : str, optional
            Character to use for beats containing multiple notes. The default is &#39;■&#39;.
        empty : str, optional
            Character to use for beats not containing notes. The default is &#39;□&#39;.
        wrap : int, optional
            How many beats (as determined by `resolution`) to show on a single line.
            The default is 32.

        Returns
        -------
        s (str) or None
            The string diagram is returned if `printout` is `False`, otherwise
            it is printed and `None` is returned.

        &#39;&#39;&#39;
        s = seqstring(self,
                      name_cutoff=name_cutoff,
                      resolution=resolution,
                      singlenote=singlenote,
                      multinote=multinote,
                      empty=empty,
                      wrap=wrap)
        if printout:
            print(s)
        else:
            return s

    def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
             plot_kwds=None):
        &#39;&#39;&#39;
        Run `wubwub.plots.sequencerplot()` for this Sequencer.

        timesig : int, optional
            Sets the ticks/grid to a given frequency of beats. The default is 4.
        grid : bool, optional
            Whether to include a grid. The default is True.
        ax : matplotlib.axes.Axes, optional
            Axes to create the plot on. The default is None.
        scatter_kwds : dict, optional
            Keyword arguments passed to `matplotlib.axes.Axes.scatter`.
            The default is None.
        plot_kwds : dict, optional
            Keyword arguments passed to `matplotlib.axes.Axes.plot`.
            The default is None.

        Returns
        -------
        matplotlib.figure.Figure
            The Figure containing the axes used.

        &#39;&#39;&#39;
        return sequencerplot(self,
                             timesig=timesig,
                             grid=grid,
                             ax=ax,
                             scatter_kwds=scatter_kwds,
                             plot_kwds=plot_kwds)


def stitch(sequencers, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#34;&#34;&#34;
    Take a list of Sequencers, and concatenate the audio produced by each one.
    A pydub `AudioSegment` is returned, which is the concatenation of
    the outputs of each Sequencer&#39;s `build()` method.

    Parameters
    ----------
    sequencers : list-like
        Sequencers to use.
    internal_overhang : int or float, optional
        Determine the length of extra time to render when the loop restarts.
        This can be used to prevent abrubt shortening of sounds near the
        end of the sequence. The default is 0, meaning all sounds are
        cut at the end of the Sequencer length for each loop.
    end_overhang : int or float, optional
        Determine the length of extra time to render at the of the audio,
        i.e. after all loops are complete. The default is 0.
    overhang_type : str -&gt; &#39;beats&#39; or &#39;seconds&#39;, optional
        Units for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    stitched : pydub.AudioSegment
        AudioSegment of the stitched audio.

    Examples
    --------

    ```python
    import wubwub as wb

    # init some dummy Sequencers
    a = wb.Sequencer(beats=8, bpm=120)
    b = wb.Sequencer(beats=4, bpm=120)

    # stitch is used to concatenate their audio (empty here)
    stitched = wb.stitch([a, b])

    # with no end_overhang, the length should be equal to the sum of lengths
    print(len(stitched) == len(a.build()) + len(b.build()))
    # True

    ```

    &#34;&#34;&#34;
    total_length = 0
    current = 0
    sectionstarts = []
    for seq in sequencers:
        b = (1/seq.bpm) * MINUTE
        seq_length = b * seq.beats
        total_length += seq_length
        sectionstarts.append(current)
        current += seq_length
    total_length += _overhang_to_milli(end_overhang, overhang_type, b)

    stitched = pydub.AudioSegment.silent(duration=total_length)
    for start, seq in zip(sectionstarts, sequencers):
        build = seq.build(internal_overhang, overhang_type)
        stitched = stitched.overlay(build, start)

    return stitched

def _matchesforjoin(oldtracks, newtrack, on=&#39;name&#39;):
    &#39;&#39;&#39;Helper method for joining two Sequencers.  Given a list of tracks
    (from one Sequencer) and a test track (from a different Sequencer), tries
    to return a matching track.&#39;&#39;&#39;
    ons = [&#39;name&#39;, &#39;sample&#39;, &#39;sample+type&#39;]
    if on not in ons:
        raise WubWubError(f&#39;`on` must be selected from {ons}&#39;)

    if on == &#39;name&#39;:
        return [track for track in oldtracks if track.name == newtrack.name]
    if on == &#39;sample&#39;:
        return [track for track in oldtracks if track.sample == newtrack.sample]
    if on == &#39;sample+type&#39;:
        return [track for track in oldtracks if track.sample == newtrack.sample
                and type(track) == type(newtrack)]
    return []

def join(sequencers, on=&#39;name&#39;):
    &#39;&#39;&#39;
    Combine multiple Sequencers into a single Sequencer.  The function
    tries to match Tracks based on either the name or sample (see the `on`
    parameter).  If a Track cannot be matched, it is kept as a separate
    entity. This hopefully works well for re-merging Sequencers created
    by `split()`, but may not work as well when merging very different
    Sequencers (please report any issues).

    Parameters
    ----------
    sequencers : list-like
        List of Sequencers to join.
    on : str, &#34;name&#34;, &#34;sample&#34;, or &#34;sample+type&#34;, optional
        Method to use for matching Tracks between adjacent Sequencers.
        If &#39;name&#39; (default), match based on the Track name.  If &#39;sample&#39;,
        match based on equivalence of the `sample` attribute. If `sample+type`,
        match based on the sample, but also on the Track being of the same
        class.

    Returns
    -------
    out : wubwub.sequencer.Sequencer
        The joined Sequencers.

    &#39;&#39;&#39;
    beats = sum(seq.beats for seq in sequencers)
    out = Sequencer(bpm=sequencers[0].bpm, beats=beats)
    offset = 0
    for i, seq in enumerate(sequencers):
        oldtracks = out.tracks()
        available = list(oldtracks)

        for track in seq.tracks():
            match = None
            matches = _matchesforjoin(available, track, on=on)
            if matches:
                match = matches[0]
                available.remove(match)

            if match:
                match.add_fromdict(track.notedict, offset=offset)

            else:
                new = track.copy(with_notes=False, newseq=out)
                new.add_fromdict(track.notedict, offset=offset)


        offset = seq.beats
    return out

def loop(sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;Calls `stitch()` on one Sequencer multiple times, to create a looped
    AudioSegment.&#39;&#39;&#39;

    return stitch([sequencer] * times,
                  internal_overhang,
                  end_overhang,
                  overhang_type)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wubwub.sequencer.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>sequencers, on='name')</span>
</code></dt>
<dd>
<div class="desc"><p>Combine multiple Sequencers into a single Sequencer.
The function
tries to match Tracks based on either the name or sample (see the <code>on</code>
parameter).
If a Track cannot be matched, it is kept as a separate
entity. This hopefully works well for re-merging Sequencers created
by <code>split()</code>, but may not work as well when merging very different
Sequencers (please report any issues).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sequencers</code></strong> :&ensp;<code>list-like</code></dt>
<dd>List of Sequencers to join.</dd>
<dt><strong><code>on</code></strong> :&ensp;<code>str, "name", "sample",</code> or <code>"sample+type"</code>, optional</dt>
<dd>Method to use for matching Tracks between adjacent Sequencers.
If 'name' (default), match based on the Track name.
If 'sample',
match based on equivalence of the <code>sample</code> attribute. If <code>sample+type</code>,
match based on the sample, but also on the Track being of the same
class.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>out</code></strong> :&ensp;<code><a title="wubwub.sequencer.Sequencer" href="#wubwub.sequencer.Sequencer">Sequencer</a></code></dt>
<dd>The joined Sequencers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(sequencers, on=&#39;name&#39;):
    &#39;&#39;&#39;
    Combine multiple Sequencers into a single Sequencer.  The function
    tries to match Tracks based on either the name or sample (see the `on`
    parameter).  If a Track cannot be matched, it is kept as a separate
    entity. This hopefully works well for re-merging Sequencers created
    by `split()`, but may not work as well when merging very different
    Sequencers (please report any issues).

    Parameters
    ----------
    sequencers : list-like
        List of Sequencers to join.
    on : str, &#34;name&#34;, &#34;sample&#34;, or &#34;sample+type&#34;, optional
        Method to use for matching Tracks between adjacent Sequencers.
        If &#39;name&#39; (default), match based on the Track name.  If &#39;sample&#39;,
        match based on equivalence of the `sample` attribute. If `sample+type`,
        match based on the sample, but also on the Track being of the same
        class.

    Returns
    -------
    out : wubwub.sequencer.Sequencer
        The joined Sequencers.

    &#39;&#39;&#39;
    beats = sum(seq.beats for seq in sequencers)
    out = Sequencer(bpm=sequencers[0].bpm, beats=beats)
    offset = 0
    for i, seq in enumerate(sequencers):
        oldtracks = out.tracks()
        available = list(oldtracks)

        for track in seq.tracks():
            match = None
            matches = _matchesforjoin(available, track, on=on)
            if matches:
                match = matches[0]
                available.remove(match)

            if match:
                match.add_fromdict(track.notedict, offset=offset)

            else:
                new = track.copy(with_notes=False, newseq=out)
                new.add_fromdict(track.notedict, offset=offset)


        offset = seq.beats
    return out</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Calls <code><a title="wubwub.sequencer.stitch" href="#wubwub.sequencer.stitch">stitch()</a></code> on one Sequencer multiple times, to create a looped
AudioSegment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;Calls `stitch()` on one Sequencer multiple times, to create a looped
    AudioSegment.&#39;&#39;&#39;

    return stitch([sequencer] * times,
                  internal_overhang,
                  end_overhang,
                  overhang_type)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.stitch"><code class="name flex">
<span>def <span class="ident">stitch</span></span>(<span>sequencers, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Take a list of Sequencers, and concatenate the audio produced by each one.
A pydub <code>AudioSegment</code> is returned, which is the concatenation of
the outputs of each Sequencer's <code>build()</code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sequencers</code></strong> :&ensp;<code>list-like</code></dt>
<dd>Sequencers to use.</dd>
<dt><strong><code>internal_overhang</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Determine the length of extra time to render when the loop restarts.
This can be used to prevent abrubt shortening of sounds near the
end of the sequence. The default is 0, meaning all sounds are
cut at the end of the Sequencer length for each loop.</dd>
<dt><strong><code>end_overhang</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Determine the length of extra time to render at the of the audio,
i.e. after all loops are complete. The default is 0.</dd>
<dt><strong><code>overhang_type</code></strong> :&ensp;<code>str -&gt; 'beats'</code> or <code>'seconds'</code>, optional</dt>
<dd>Units for the overhang. The default is 'beats'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stitched</code></strong> :&ensp;<code>pydub.AudioSegment</code></dt>
<dd>AudioSegment of the stitched audio.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">import wubwub as wb

# init some dummy Sequencers
a = wb.Sequencer(beats=8, bpm=120)
b = wb.Sequencer(beats=4, bpm=120)

# stitch is used to concatenate their audio (empty here)
stitched = wb.stitch([a, b])

# with no end_overhang, the length should be equal to the sum of lengths
print(len(stitched) == len(a.build()) + len(b.build()))
# True

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stitch(sequencers, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#34;&#34;&#34;
    Take a list of Sequencers, and concatenate the audio produced by each one.
    A pydub `AudioSegment` is returned, which is the concatenation of
    the outputs of each Sequencer&#39;s `build()` method.

    Parameters
    ----------
    sequencers : list-like
        Sequencers to use.
    internal_overhang : int or float, optional
        Determine the length of extra time to render when the loop restarts.
        This can be used to prevent abrubt shortening of sounds near the
        end of the sequence. The default is 0, meaning all sounds are
        cut at the end of the Sequencer length for each loop.
    end_overhang : int or float, optional
        Determine the length of extra time to render at the of the audio,
        i.e. after all loops are complete. The default is 0.
    overhang_type : str -&gt; &#39;beats&#39; or &#39;seconds&#39;, optional
        Units for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    stitched : pydub.AudioSegment
        AudioSegment of the stitched audio.

    Examples
    --------

    ```python
    import wubwub as wb

    # init some dummy Sequencers
    a = wb.Sequencer(beats=8, bpm=120)
    b = wb.Sequencer(beats=4, bpm=120)

    # stitch is used to concatenate their audio (empty here)
    stitched = wb.stitch([a, b])

    # with no end_overhang, the length should be equal to the sum of lengths
    print(len(stitched) == len(a.build()) + len(b.build()))
    # True

    ```

    &#34;&#34;&#34;
    total_length = 0
    current = 0
    sectionstarts = []
    for seq in sequencers:
        b = (1/seq.bpm) * MINUTE
        seq_length = b * seq.beats
        total_length += seq_length
        sectionstarts.append(current)
        current += seq_length
    total_length += _overhang_to_milli(end_overhang, overhang_type, b)

    stitched = pydub.AudioSegment.silent(duration=total_length)
    for start, seq in zip(sectionstarts, sequencers):
        build = seq.build(internal_overhang, overhang_type)
        stitched = stitched.overlay(build, start)

    return stitched</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wubwub.sequencer.Sequencer"><code class="flex name class">
<span>class <span class="ident">Sequencer</span></span>
<span>(</span><span>bpm, beats)</span>
</code></dt>
<dd>
<div class="desc"><p>The Sequencer is the main tool for creating beats in wubwub.
Sequencers
hold and organize individual instrument Tracks which can be filled
with musical elements.
Sequencers have a defined length (and tempo), but
multiple can be combined to create longer/varied arrangements.</p>
<p>Both parameters for initialization (BPM and length) can be tweaked
after creation by setting the value of the <code>bpm</code> or
<code>beats</code> attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bpm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Tempo of the sequencer (beats per minute).</dd>
<dt><strong><code>beats</code></strong> :&ensp;<code>int</code></dt>
<dd>The length of the sequence, in beats.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Initialize a Sequencer with a tempo and length:</p>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb
&gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
&gt;&gt;&gt; seq
Sequencer(bpm=120, beats=8, tracks=0)

</code></pre>
<p>Initialization function for the Sequencer.
Sets the BPM and beats
based on user input, also defaults attributes related to post-processing
the output audio and creates a container for subsidiary tracks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequencer:
    &#39;&#39;&#39;
    The Sequencer is the main tool for creating beats in wubwub.  Sequencers
    hold and organize individual instrument Tracks which can be filled
    with musical elements.  Sequencers have a defined length (and tempo), but
    multiple can be combined to create longer/varied arrangements.

    Both parameters for initialization (BPM and length) can be tweaked
    after creation by setting the value of the &lt;code&gt;bpm&lt;/code&gt; or
    &lt;code&gt;beats&lt;/code&gt; attributes.

    Parameters
    ----------
    bpm : int or float
        Tempo of the sequencer (beats per minute).
    beats : int
        The length of the sequence, in beats.

    Examples
    --------
    Initialize a Sequencer with a tempo and length:

    ```python
    &gt;&gt;&gt; import wubwub as wb
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq
    Sequencer(bpm=120, beats=8, tracks=0)

    ```
    &#39;&#39;&#39;

    def __init__(self, bpm, beats):
        &#34;&#34;&#34;Initialization function for the Sequencer.  Sets the BPM and beats
        based on user input, also defaults attributes related to post-processing
        the output audio and creates a container for subsidiary tracks.&#34;&#34;&#34;

        self.bpm = bpm
        self.beats = beats

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._tracks = []

    def __repr__(self):
        &#34;&#34;&#34;String representation of self.&#34;&#34;&#34;
        l = len(self.tracks())
        return f&#34;Sequencer(bpm={self.bpm}, beats={self.beats}, tracks={l})&#34;

    def __getitem__(self, name):
        &#34;&#34;&#34;Allows for retrieval of Track objects by their string name.&#34;&#34;&#34;
        if not isinstance(name, str):
            e = f&#39;Can only index Sequencer with str, not {type(name)}&#39;
            raise WubWubError(e)
        return self.get_track(name)

    def _add_track(self, track):
        &#34;&#34;&#34;Helper function called when adding a new track to self.  Checks for
        duplicate names, and tries to ensure non-duplicate entries of items
        in different Sequencers.&#34;&#34;&#34;
        if track.name in self.tracknames():
            raise WubWubError(f&#39;Track name &#34;{track.name}&#34; already in use.&#39;)
        if track.sequencer != self:
            track.sequencer = self
        if track not in self._tracks:
            self._tracks.append(track)

    def copypaste_section(self, start, stop, newstart):
        &#39;&#39;&#39;
        For all tracks of the Sequencer, take a section of notes and replicate
        them on a new beat (keeping the same relative spacing between notes).
        Simply, this method calls `wubwub.tracks.Track.copypaste()`
        for all tracks within the Sequencer.

        Parameters
        ----------
        start : int or float
            Beat to start copying notes (inclusive).
        stop : int or float
            Beat to stop copying notes (exlcusive).
        newstart : int or float
            Beat to paste the copied section.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for track in self.tracks():
            track.copypaste(start, stop, newstart)

    def set_beats_and_clean(self, new):
        &#34;&#34;&#34;
        Modifies the Sequencer length while simultaneously removing notes
        that are outside of the sequence after the change.  I.e., sets
        &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks.Track.clean()` for
        all tracks.  This is a convenience method which is only useful when
        shortening the sequence length.

        Parameters
        ----------
        new : int
            New value for the length of the Sequencer.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.beats = new
        for track in self.tracks():
            track.clean()

    def get_track(self, track):
        &#39;&#39;&#39;
        Return a Track, keyed by either its name or the Track
        itself (provided the Track is part of the current Sequencer).

        Parameters
        ----------
        track : str or Track
            Handle for a Track to retrieve.

        Raises
        ------
        ValueError
            Track not found.

        Returns
        -------
        Track
            A track that is part of this Sequencer.

        &#39;&#39;&#39;
        if isinstance(track, str):
            try:
                return next(t for t in self._tracks if t.name == track)
            except:
                raise ValueError(f&#39;no track with name {track}&#39;)
        elif track in self._tracks:
            return track
        else:
            raise ValueError(&#39;Requested track is not part of sequencer.&#39;)

    def tracks(self):
        &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
        return tuple(self._tracks)

    def tracknames(self):
        &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
        return [t.name for t in self._tracks]

    def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
        &#34;&#34;&#34;
        Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Sampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Returns
        -------
        new : wubwub.tracks.Sampler
            The new Track.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound
        seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

        # using a pydub.AudioSegment
        import wubwub.sounds as snd

        clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
        seq.add_sampler(clap, name=&#39;clap&#39;)
        ```

        &#34;&#34;&#34;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Sampler(name=name, sample=sample, overlap=overlap,
                      basepitch=basepitch, sequencer=self)
        return new

    def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                        basepitch=&#39;C4&#39;):
        &#39;&#39;&#39;
        Create a new `wubwub.tracks.Arpeggiator` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Arpeggiator`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        freq : int or float, optional
            Set the frequency of the new arpeggiator. The default is 0.5.
        method : str, optional
            Set the pattern of the new arpeggiator. The default is &#39;up&#39;.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Returns
        -------
        new : wubwub.tracks.Arpeggiator
            The new Track.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound, or a pydub.AudioSegment
        seq.add_arpeggiator(&#39;saw.wav&#39;, name=&#39;Arp&#39;, freq=.5, method=&#39;downup&#39;)
        ```

        &#39;&#39;&#39;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Arpeggiator(name=name, sample=sample, freq=freq,
                          method=method, basepitch=basepitch,
                          sequencer=self)
        return new

    def add_multisampler(self, name=None, overlap=False):
        &#39;&#39;&#39;
        Create a new `wubwub.tracks.MultiSampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.MultiSampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.

        Returns
        -------
        new : wubwub.tracks.MultiSampler
            The new Track.

        &#39;&#39;&#39;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = MultiSampler(name=name, overlap=overlap, sequencer=self)
        return new

    def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
        &#39;&#39;&#39;
        From a list of sounds or pydub Audio Segments, add multiple
        `wubwub.tracks.Sampler` Tracks.

        Parameters
        ----------
        samples : list like
            List of paths to sounds, or pydub AudioSegments to load.
        names : list like, optional
            The string name of each sample being added. The default is None.
        overlap : bool, optional
            The overlap behavior of the new samplers. The default is False.
        basepitch : int or str, optional
            The base pitch of the new samplers. The default is &#39;C4&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        if names is None:
            names = [None] * len(samples)
        for sample, name in zip(samples, names):
            self.add_sampler(sample=sample, name=name, overlap=overlap,
                             basepitch=basepitch)

    def duplicate_track(self, track, newname=None, with_notes=True):
        &#39;&#39;&#39;
        Create a copy of the specified Track within and add it to the
        current Sequencer.

        Parameters
        ----------
        track : wubwub.tracks.Track or str
            Name of a Track, or the actual Track object.
        newname : str, optional
            New name for the duplicated Track. The default is None.  If not passed,
            a generic name is created.
        with_notes : bool, optional
            When True (default), all the Notes/Chords contained in the original
            Track are copied over.

        Returns
        -------
        dup : wubwub.tracks.Track
            Reference to the new Track.

        Examples
        --------

        ```python
        &gt;&gt;&gt; import wubwub as wb

        # add a track with some notes
        &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
        &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)
        &gt;&gt;&gt; seq[&#39;kick1&#39;].make_notes_every(1)

        # duplicate the track
        &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick2&#39;)

        # by default, the notes are copied
        &gt;&gt;&gt; len(seq[&#39;kick2&#39;].notedict)
        8

        # specify with_notes to change this behavior
        &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick3&#39;, with_notes=False)
        &gt;&gt;&gt; len(seq[&#39;kick3&#39;].notedict)
        0
        ```

        &#39;&#39;&#39;
        if newname is None:
            newname = unique_name(&#39;Track&#39;, self.tracknames())
        dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
        return dup

    def copy(self, with_notes=True):
        &#39;&#39;&#39;
        Create a copy of the current Sequencer.  The copy (and its associated
        Tracks) are *new objects*, so editing it will not affect this Sequencer
        (and vice versa).


        Parameters
        ----------
        with_notes : bool, optional
            When True (default), all the Notes/Chords are copied over for
            every copied track.

        Returns
        -------
        new : wubwub.sequencer.Sequencer
            The new Sequencer.

        Examples
        --------

        ```python
        &gt;&gt;&gt; import wubwub as wb

        # add a track
        &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
        &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)

        # copy the sequencer
        &gt;&gt;&gt; other = seq.copy()

        # editing the new sequencer doesn&#39;t affect the original
        &gt;&gt;&gt; other.delete_track(&#39;kick1&#39;)
        &gt;&gt;&gt; other.tracknames()
        []

        &gt;&gt;&gt; seq.tracknames()
        [&#39;kick1&#39;]
        ```

        &#39;&#39;&#39;
        new = Sequencer(beats=self.beats, bpm=self.bpm)
        for track in self.tracks():
            track.copy(with_notes=with_notes, newseq=new)
        return new

    def split(self, beat):
        &#39;&#39;&#39;
        Split the Sequencer into two new Sequencers at a given beat.  The objects
        returned are *new Sequencers* (generated by `Sequencer.copy()`).

        Parameters
        ----------
        beat : int
            The beat to split the Sequencer on.

        Raises
        ------
        TypeError
            Non-integer beat is passed.

        Returns
        -------
        a, b : wubwub.sequencer.Sequencer
            Two new Sequencers.

        Examples
        --------
        ```python
        &gt;&gt;&gt; import wubwub as wb
        &gt;&gt;&gt; import wubwub.sounds as snd

        # make a sequencer and add tracks/notes
        &gt;&gt;&gt; seq = wb.Sequencer(beats=8, bpm=100)
        &gt;&gt;&gt; drums = snd.load(&#39;drums.808&#39;)
        &gt;&gt;&gt; kick = seq.add_sampler(drums[&#39;kick1&#39;], name=&#39;kick&#39;)
        &gt;&gt;&gt; snare = seq.add_sampler(drums[&#39;snare&#39;], name=&#39;snare&#39;)
        &gt;&gt;&gt; kick.make_notes_every(2)
        &gt;&gt;&gt; snare.make_notes_every(2, offset=1)
        &gt;&gt;&gt; seq.show()
              1 2 3 4 5 6 7 8
         kick ■ □ ■ □ ■ □ ■ □
        snare □ ■ □ ■ □ ■ □ ■

        # split
        &gt;&gt;&gt; a, b = seq.split(4)

        # show
        &gt;&gt;&gt; a.show()
              1 2 3
         kick ■ □ ■
        snare □ ■ □

        &gt;&gt;&gt; b.show()
              1 2 3 4 5
         kick □ ■ □ ■ □
        snare ■ □ ■ □ ■
        ```

        &#39;&#39;&#39;
        if not isinstance(beat, int):
            raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

        a1, a2 = (1, beat)
        b1, b2 = (beat, self.beats+1)

        a = self.copy(with_notes=False)
        a.beats = a2 - a1
        b = self.copy(with_notes=False)
        b.beats = b2 - b1

        for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
            anotes = selftrack.slice[a1:a2]
            atrack.add_fromdict(anotes)
            bnotes = selftrack.slice[b1:b2]
            btrack.add_fromdict(bnotes, offset=(-beat + 1))

        return a, b

    def delete_track(self, track):
        &#34;&#34;&#34;
        Delete a Track from the Sequencer, along with any entered Notes.

        Parameters
        ----------
        track : str or wubwub.tracks.Track
            Reference to the Track to delete.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        t = self.get_track(track)
        t.sequencer = None
        self._tracks.remove(t)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Render all the contained Tracks into one output, namely a pydub
        AudioSegment.  Calls the &#34;build&#34; method of each Track, and overlays
        them.

        Parameters
        ----------
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        pydub.AudioSegment
            The rendered audio.

        Examples
        --------
        ```python
        &gt;&gt;&gt; import wubwub as wb

        # 60 BPM == 1 second per beat
        &gt;&gt;&gt; seq = wb.Sequencer(beats=4, bpm=60)

        # expected length (in milliseconds, per pydub)
        &gt;&gt;&gt; expected = 4 * 1000
        &gt;&gt;&gt; expected == len(seq.build())
        True

        # add overhang of 2 beats
        &gt;&gt;&gt; len(seq.build(overhang=2))
        6000

        # add overhang in seconds
        &gt;&gt;&gt; len(seq.build(overhang=3.777, overhang_type=&#39;beats&#39;))
        7777
        ```

        &#39;&#39;&#39;
        b = (1/self.bpm) * MINUTE
        seq_oh = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.beats * b + seq_oh
        audio = pydub.AudioSegment.silent(duration=tracklength)
        for track in self.tracks():
            audio = audio.overlay(track.build(overhang, overhang_type))
        return self.postprocess(audio)

    def postprocess(self, build):
        &#39;&#39;&#39;
        Add postprocessing to a rendered audio output of the Sequencer,
        typically that of `Sequencer.build()`.  There are currently 3
        postprocessing steps applied, corresponding to 3 attributes of
        the Sequencer:

        - `effects`: This attribute can be set to a pysndfx
        AudioEffectsChain instance to add audio effects (such as reverb,
        delay, overdrive, etc.) See
        [here](https://github.com/carlthome/python-audio-effects) for more
        documentation.
        - `volume`: This attribute can be set to modify the output volume
        of the build.  Note that the value reflects a relative change in
        dB, so values can be positive or negative.
        - `pan`: a value between `-1.0` (100% left) and `+1.0` (100% right)
        indicating the stereo panning (`0.0` is centered).

        The order/presence of these processing steps can be determined by
        setting the `postprocess_steps` attribute, which should be a list
        containing some subset of the strings `&#39;effects&#39;`, `&#39;volume&#39;`, and
        `&#39;pan`&#39; (corresponding to each of the three steps above).  The default
        is `self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]`.  *Omitted
        steps in this attribute will not be applied, while repeated steps
        will be applied multiple times.*  Additionally, the steps are applied
        in the order encountered in `self.postprocess_steps`.

        Parameters
        ----------
        build : pydub AudioSegment
            Audio to postprocess, typically output of `Sequencer.build()`

        Returns
        -------
        build : pydub AudioSegment
            Audio with postprocessing steps applied.

        &#39;&#39;&#39;
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Audio playback of the Sequencer.

        Parameters
        ----------
        start : int, optional
            Beat to start playback on. The default is 1.
        end : int or None, optional
            Beat to end playback on. The default is None.
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        b = (1/self.bpm) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Return a looped rendering of the Sequencer.  This is akin to
        `Sequencer.build()`, but the content of the Sequencer is repeated
        a specified number of times.

        Parameters
        ----------
        times : int, optional
            How many times to loop. The default is 4.
        internal_overhang : int or float, optional
            Determine the length of extra time to render when the loop restarts.
            This can be used to prevent abrubt shortening of sounds near the
            end of the sequence. The default is 0, meaning all sounds are
            cut at the end of the Sequencer length for each loop.
        end_overhang : int or float, optional
            Determine the length of extra time to render at the of the audio,
            i.e. after all loops are complete. The default is 0.
        overhang_type : str -&gt; &#39;beats&#39; or &#39;seconds&#39;, optional
            Units for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        looped : pydub.AudioSegment
            The looped audio.

        &#39;&#39;&#39;
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        return looped

    def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;Calls `Sequencer.play()` on `Sequencer.loop()`; i.e.
        immediately plays back looped audio.&#39;&#39;&#39;
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        play(looped)

    def soundtest(self, selection=None, postprocess=True, gap=.5):
        &#39;&#39;&#39;Calls the sound test method for each Track in the Sequencer; i.e.
        plays back all the samples being used.&#39;&#39;&#39;
        if selection is None:
            selection = self.tracks()
        else:
            selection = [self.get_track(i) for i in selection]

        for track in selection:
            print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
            time.sleep(.25)
            track.soundtest(postprocess=postprocess)
            time.sleep(gap)

    def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
        &#39;&#39;&#39;
        Saves the rendered audio to a file.  The Sequencer creates
        a pydub AudioSegment which contains all Tracks overlaid,
        and then uses its export method to save.

        See the pydub documentation for more information on exporting.

        Parameters
        ----------
        path : system path
            File path to save the audio to.
        overhang : int or number, optional
            How much extra time to render beyond the length
            (i.e., the `beats`) of the Sequencer. The default is 0.
            Units are either in beats or in seconds, dependent on the
            `overhang_type` argument.  This can be useful when there are
            notes or effects that reverberate beyond the duration of the
            Sequencer.
        overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
            Unit for the overhang. The default is &#39;beats&#39;.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        _, fmt = os.path.splitext(path)
        build = self.build(overhang, overhang_type)
        build.export(path, format=fmt)

    def show(self, printout=True, name_cutoff=None, resolution=1,
             singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
        &#39;&#39;&#39;
        Print (or return) a sequencer grid diagram, showing when
        each Track contains notes.  For more information, see
        `wubwub.seqstring.seqstring()`.

        Parameters
        ----------
        printout : bool, optional
            When True (default), print the diagram.  When False,
            return the string.
        name_cutoff : int, optional
            Number of characters to allow track names to be. The default is None.
        resolution : int or float, optional
            Determines the frequency of beats to use. The default is 1.
        singlenote : str, optional
            Character to use for beats containing single Notes. The default is &#39;■&#39;.
        multinote : str, optional
            Character to use for beats containing multiple notes. The default is &#39;■&#39;.
        empty : str, optional
            Character to use for beats not containing notes. The default is &#39;□&#39;.
        wrap : int, optional
            How many beats (as determined by `resolution`) to show on a single line.
            The default is 32.

        Returns
        -------
        s (str) or None
            The string diagram is returned if `printout` is `False`, otherwise
            it is printed and `None` is returned.

        &#39;&#39;&#39;
        s = seqstring(self,
                      name_cutoff=name_cutoff,
                      resolution=resolution,
                      singlenote=singlenote,
                      multinote=multinote,
                      empty=empty,
                      wrap=wrap)
        if printout:
            print(s)
        else:
            return s

    def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
             plot_kwds=None):
        &#39;&#39;&#39;
        Run `wubwub.plots.sequencerplot()` for this Sequencer.

        timesig : int, optional
            Sets the ticks/grid to a given frequency of beats. The default is 4.
        grid : bool, optional
            Whether to include a grid. The default is True.
        ax : matplotlib.axes.Axes, optional
            Axes to create the plot on. The default is None.
        scatter_kwds : dict, optional
            Keyword arguments passed to `matplotlib.axes.Axes.scatter`.
            The default is None.
        plot_kwds : dict, optional
            Keyword arguments passed to `matplotlib.axes.Axes.plot`.
            The default is None.

        Returns
        -------
        matplotlib.figure.Figure
            The Figure containing the axes used.

        &#39;&#39;&#39;
        return sequencerplot(self,
                             timesig=timesig,
                             grid=grid,
                             ax=ax,
                             scatter_kwds=scatter_kwds,
                             plot_kwds=plot_kwds)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wubwub.sequencer.Sequencer.add_arpeggiator"><code class="name flex">
<span>def <span class="ident">add_arpeggiator</span></span>(<span>self, sample, name=None, freq=0.5, method='up', basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="wubwub.tracks.Arpeggiator" href="tracks.html#wubwub.tracks.Arpeggiator">Arpeggiator</a></code> Track and add to the Sequencer.
Parameters here are initialization values for <code><a title="wubwub.tracks.Arpeggiator" href="tracks.html#wubwub.tracks.Arpeggiator">Arpeggiator</a></code>;
see there for more detailed documentation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample</code></strong> :&ensp;<code>path</code> or <code>pydub.AudioSegment</code></dt>
<dd>Sample for Sampler initialization.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the new Sampler.</dd>
<dt><strong><code>freq</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Set the frequency of the new arpeggiator. The default is 0.5.</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Set the pattern of the new arpeggiator. The default is 'up'.</dd>
<dt><strong><code>basepitch</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>Set the base pitch for the new Sampler. The default is 'C4'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code><a title="wubwub.tracks.Arpeggiator" href="tracks.html#wubwub.tracks.Arpeggiator">Arpeggiator</a></code></dt>
<dd>The new Track.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">import wubwub as wb

seq = wb.Sequencer(bpm=100, beats=16)

# path to sound, or a pydub.AudioSegment
seq.add_arpeggiator('saw.wav', name='Arp', freq=.5, method='downup')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                    basepitch=&#39;C4&#39;):
    &#39;&#39;&#39;
    Create a new `wubwub.tracks.Arpeggiator` Track and add to the Sequencer.
    Parameters here are initialization values for `wubwub.tracks.Arpeggiator`;
    see there for more detailed documentation.

    Parameters
    ----------
    sample : path or pydub.AudioSegment
        Sample for Sampler initialization.
    name : str, optional
        Name for the new Sampler.
    freq : int or float, optional
        Set the frequency of the new arpeggiator. The default is 0.5.
    method : str, optional
        Set the pattern of the new arpeggiator. The default is &#39;up&#39;.
    basepitch : int or str, optional
        Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

    Returns
    -------
    new : wubwub.tracks.Arpeggiator
        The new Track.

    Examples
    --------
    ```python
    import wubwub as wb

    seq = wb.Sequencer(bpm=100, beats=16)

    # path to sound, or a pydub.AudioSegment
    seq.add_arpeggiator(&#39;saw.wav&#39;, name=&#39;Arp&#39;, freq=.5, method=&#39;downup&#39;)
    ```

    &#39;&#39;&#39;
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = Arpeggiator(name=name, sample=sample, freq=freq,
                      method=method, basepitch=basepitch,
                      sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_multisampler"><code class="name flex">
<span>def <span class="ident">add_multisampler</span></span>(<span>self, name=None, overlap=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="wubwub.tracks.MultiSampler" href="tracks.html#wubwub.tracks.MultiSampler">MultiSampler</a></code> Track and add to the Sequencer.
Parameters here are initialization values for <code><a title="wubwub.tracks.MultiSampler" href="tracks.html#wubwub.tracks.MultiSampler">MultiSampler</a></code>;
see there for more detailed documentation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the new Sampler.</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set the overlap behavior of the new Sampler. The default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code><a title="wubwub.tracks.MultiSampler" href="tracks.html#wubwub.tracks.MultiSampler">MultiSampler</a></code></dt>
<dd>The new Track.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_multisampler(self, name=None, overlap=False):
    &#39;&#39;&#39;
    Create a new `wubwub.tracks.MultiSampler` Track and add to the Sequencer.
    Parameters here are initialization values for `wubwub.tracks.MultiSampler`;
    see there for more detailed documentation.

    Parameters
    ----------
    name : str, optional
        Name for the new Sampler.
    overlap : bool, optional
        Set the overlap behavior of the new Sampler. The default is False.

    Returns
    -------
    new : wubwub.tracks.MultiSampler
        The new Track.

    &#39;&#39;&#39;
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = MultiSampler(name=name, overlap=overlap, sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_sampler"><code class="name flex">
<span>def <span class="ident">add_sampler</span></span>(<span>self, sample, name=None, overlap=False, basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code> Track and add to the Sequencer.
Parameters here are initialization values for <code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code>;
see there for more detailed documentation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample</code></strong> :&ensp;<code>path</code> or <code>pydub.AudioSegment</code></dt>
<dd>Sample for Sampler initialization.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the new Sampler.</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set the overlap behavior of the new Sampler. The default is False.</dd>
<dt><strong><code>basepitch</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>Set the base pitch for the new Sampler. The default is 'C4'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code></dt>
<dd>The new Track.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">import wubwub as wb

seq = wb.Sequencer(bpm=100, beats=16)

# path to sound
seq.add_sampler('my_kick.wav', name='kick')

# using a pydub.AudioSegment
import wubwub.sounds as snd

clap = snd.load('drums.808')['handclap']
seq.add_sampler(clap, name='clap')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
    &#34;&#34;&#34;
    Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
    Parameters here are initialization values for `wubwub.tracks.Sampler`;
    see there for more detailed documentation.

    Parameters
    ----------
    sample : path or pydub.AudioSegment
        Sample for Sampler initialization.
    name : str, optional
        Name for the new Sampler.
    overlap : bool, optional
        Set the overlap behavior of the new Sampler. The default is False.
    basepitch : int or str, optional
        Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

    Returns
    -------
    new : wubwub.tracks.Sampler
        The new Track.

    Examples
    --------
    ```python
    import wubwub as wb

    seq = wb.Sequencer(bpm=100, beats=16)

    # path to sound
    seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

    # using a pydub.AudioSegment
    import wubwub.sounds as snd

    clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
    seq.add_sampler(clap, name=&#39;clap&#39;)
    ```

    &#34;&#34;&#34;
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = Sampler(name=name, sample=sample, overlap=overlap,
                  basepitch=basepitch, sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_samplers"><code class="name flex">
<span>def <span class="ident">add_samplers</span></span>(<span>self, samples, names=None, overlap=False, basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"><p>From a list of sounds or pydub Audio Segments, add multiple
<code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code> Tracks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>samples</code></strong> :&ensp;<code>list like</code></dt>
<dd>List of paths to sounds, or pydub AudioSegments to load.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list like</code>, optional</dt>
<dd>The string name of each sample being added. The default is None.</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The overlap behavior of the new samplers. The default is False.</dd>
<dt><strong><code>basepitch</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>The base pitch of the new samplers. The default is 'C4'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
    &#39;&#39;&#39;
    From a list of sounds or pydub Audio Segments, add multiple
    `wubwub.tracks.Sampler` Tracks.

    Parameters
    ----------
    samples : list like
        List of paths to sounds, or pydub AudioSegments to load.
    names : list like, optional
        The string name of each sample being added. The default is None.
    overlap : bool, optional
        The overlap behavior of the new samplers. The default is False.
    basepitch : int or str, optional
        The base pitch of the new samplers. The default is &#39;C4&#39;.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    if names is None:
        names = [None] * len(samples)
    for sample, name in zip(samples, names):
        self.add_sampler(sample=sample, name=name, overlap=overlap,
                         basepitch=basepitch)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Render all the contained Tracks into one output, namely a pydub
AudioSegment.
Calls the "build" method of each Track, and overlays
them.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>overhang</code></strong> :&ensp;<code>int</code> or <code>number</code>, optional</dt>
<dd>How much extra time to render beyond the length
(i.e., the <code>beats</code>) of the Sequencer. The default is 0.
Units are either in beats or in seconds, dependent on the
<code>overhang_type</code> argument.
This can be useful when there are
notes or effects that reverberate beyond the duration of the
Sequencer.</dd>
<dt><strong><code>overhang_type</code></strong> :&ensp;<code>str -&gt; "beats"</code> or <code>"seconds"</code>, optional</dt>
<dd>Unit for the overhang. The default is 'beats'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pydub.AudioSegment</code></dt>
<dd>The rendered audio.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb

# 60 BPM == 1 second per beat
&gt;&gt;&gt; seq = wb.Sequencer(beats=4, bpm=60)

# expected length (in milliseconds, per pydub)
&gt;&gt;&gt; expected = 4 * 1000
&gt;&gt;&gt; expected == len(seq.build())
True

# add overhang of 2 beats
&gt;&gt;&gt; len(seq.build(overhang=2))
6000

# add overhang in seconds
&gt;&gt;&gt; len(seq.build(overhang=3.777, overhang_type='beats'))
7777
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;
    Render all the contained Tracks into one output, namely a pydub
    AudioSegment.  Calls the &#34;build&#34; method of each Track, and overlays
    them.

    Parameters
    ----------
    overhang : int or number, optional
        How much extra time to render beyond the length
        (i.e., the `beats`) of the Sequencer. The default is 0.
        Units are either in beats or in seconds, dependent on the
        `overhang_type` argument.  This can be useful when there are
        notes or effects that reverberate beyond the duration of the
        Sequencer.
    overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
        Unit for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    pydub.AudioSegment
        The rendered audio.

    Examples
    --------
    ```python
    &gt;&gt;&gt; import wubwub as wb

    # 60 BPM == 1 second per beat
    &gt;&gt;&gt; seq = wb.Sequencer(beats=4, bpm=60)

    # expected length (in milliseconds, per pydub)
    &gt;&gt;&gt; expected = 4 * 1000
    &gt;&gt;&gt; expected == len(seq.build())
    True

    # add overhang of 2 beats
    &gt;&gt;&gt; len(seq.build(overhang=2))
    6000

    # add overhang in seconds
    &gt;&gt;&gt; len(seq.build(overhang=3.777, overhang_type=&#39;beats&#39;))
    7777
    ```

    &#39;&#39;&#39;
    b = (1/self.bpm) * MINUTE
    seq_oh = _overhang_to_milli(overhang, overhang_type, b)
    tracklength = self.beats * b + seq_oh
    audio = pydub.AudioSegment.silent(duration=tracklength)
    for track in self.tracks():
        audio = audio.overlay(track.build(overhang, overhang_type))
    return self.postprocess(audio)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, with_notes=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of the current Sequencer.
The copy (and its associated
Tracks) are <em>new objects</em>, so editing it will not affect this Sequencer
(and vice versa).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>with_notes</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), all the Notes/Chords are copied over for
every copied track.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code><a title="wubwub.sequencer.Sequencer" href="#wubwub.sequencer.Sequencer">Sequencer</a></code></dt>
<dd>The new Sequencer.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb

# add a track
&gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
&gt;&gt;&gt; seq.add_sampler(snd.load('drums.808')['kick1'], name='kick1')

# copy the sequencer
&gt;&gt;&gt; other = seq.copy()

# editing the new sequencer doesn't affect the original
&gt;&gt;&gt; other.delete_track('kick1')
&gt;&gt;&gt; other.tracknames()
[]

&gt;&gt;&gt; seq.tracknames()
['kick1']
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, with_notes=True):
    &#39;&#39;&#39;
    Create a copy of the current Sequencer.  The copy (and its associated
    Tracks) are *new objects*, so editing it will not affect this Sequencer
    (and vice versa).


    Parameters
    ----------
    with_notes : bool, optional
        When True (default), all the Notes/Chords are copied over for
        every copied track.

    Returns
    -------
    new : wubwub.sequencer.Sequencer
        The new Sequencer.

    Examples
    --------

    ```python
    &gt;&gt;&gt; import wubwub as wb

    # add a track
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)

    # copy the sequencer
    &gt;&gt;&gt; other = seq.copy()

    # editing the new sequencer doesn&#39;t affect the original
    &gt;&gt;&gt; other.delete_track(&#39;kick1&#39;)
    &gt;&gt;&gt; other.tracknames()
    []

    &gt;&gt;&gt; seq.tracknames()
    [&#39;kick1&#39;]
    ```

    &#39;&#39;&#39;
    new = Sequencer(beats=self.beats, bpm=self.bpm)
    for track in self.tracks():
        track.copy(with_notes=with_notes, newseq=new)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.copypaste_section"><code class="name flex">
<span>def <span class="ident">copypaste_section</span></span>(<span>self, start, stop, newstart)</span>
</code></dt>
<dd>
<div class="desc"><p>For all tracks of the Sequencer, take a section of notes and replicate
them on a new beat (keeping the same relative spacing between notes).
Simply, this method calls <code><a title="wubwub.tracks.Track.copypaste" href="tracks.html#wubwub.tracks.Track.copypaste">Track.copypaste()</a></code>
for all tracks within the Sequencer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to start copying notes (inclusive).</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to stop copying notes (exlcusive).</dd>
<dt><strong><code>newstart</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to paste the copied section.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copypaste_section(self, start, stop, newstart):
    &#39;&#39;&#39;
    For all tracks of the Sequencer, take a section of notes and replicate
    them on a new beat (keeping the same relative spacing between notes).
    Simply, this method calls `wubwub.tracks.Track.copypaste()`
    for all tracks within the Sequencer.

    Parameters
    ----------
    start : int or float
        Beat to start copying notes (inclusive).
    stop : int or float
        Beat to stop copying notes (exlcusive).
    newstart : int or float
        Beat to paste the copied section.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    for track in self.tracks():
        track.copypaste(start, stop, newstart)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.delete_track"><code class="name flex">
<span>def <span class="ident">delete_track</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a Track from the Sequencer, along with any entered Notes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code>str</code> or <code><a title="wubwub.tracks.Track" href="tracks.html#wubwub.tracks.Track">Track</a></code></dt>
<dd>Reference to the Track to delete.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_track(self, track):
    &#34;&#34;&#34;
    Delete a Track from the Sequencer, along with any entered Notes.

    Parameters
    ----------
    track : str or wubwub.tracks.Track
        Reference to the Track to delete.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    t = self.get_track(track)
    t.sequencer = None
    self._tracks.remove(t)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.duplicate_track"><code class="name flex">
<span>def <span class="ident">duplicate_track</span></span>(<span>self, track, newname=None, with_notes=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of the specified Track within and add it to the
current Sequencer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code><a title="wubwub.tracks.Track" href="tracks.html#wubwub.tracks.Track">Track</a></code> or <code>str</code></dt>
<dd>Name of a Track, or the actual Track object.</dd>
<dt><strong><code>newname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>New name for the duplicated Track. The default is None.
If not passed,
a generic name is created.</dd>
<dt><strong><code>with_notes</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), all the Notes/Chords contained in the original
Track are copied over.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>dup</code></strong> :&ensp;<code><a title="wubwub.tracks.Track" href="tracks.html#wubwub.tracks.Track">Track</a></code></dt>
<dd>Reference to the new Track.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb

# add a track with some notes
&gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
&gt;&gt;&gt; seq.add_sampler(snd.load('drums.808')['kick1'], name='kick1')
&gt;&gt;&gt; seq['kick1'].make_notes_every(1)

# duplicate the track
&gt;&gt;&gt; seq.duplicate_track('kick1', newname='kick2')

# by default, the notes are copied
&gt;&gt;&gt; len(seq['kick2'].notedict)
8

# specify with_notes to change this behavior
&gt;&gt;&gt; seq.duplicate_track('kick1', newname='kick3', with_notes=False)
&gt;&gt;&gt; len(seq['kick3'].notedict)
0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def duplicate_track(self, track, newname=None, with_notes=True):
    &#39;&#39;&#39;
    Create a copy of the specified Track within and add it to the
    current Sequencer.

    Parameters
    ----------
    track : wubwub.tracks.Track or str
        Name of a Track, or the actual Track object.
    newname : str, optional
        New name for the duplicated Track. The default is None.  If not passed,
        a generic name is created.
    with_notes : bool, optional
        When True (default), all the Notes/Chords contained in the original
        Track are copied over.

    Returns
    -------
    dup : wubwub.tracks.Track
        Reference to the new Track.

    Examples
    --------

    ```python
    &gt;&gt;&gt; import wubwub as wb

    # add a track with some notes
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq.add_sampler(snd.load(&#39;drums.808&#39;)[&#39;kick1&#39;], name=&#39;kick1&#39;)
    &gt;&gt;&gt; seq[&#39;kick1&#39;].make_notes_every(1)

    # duplicate the track
    &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick2&#39;)

    # by default, the notes are copied
    &gt;&gt;&gt; len(seq[&#39;kick2&#39;].notedict)
    8

    # specify with_notes to change this behavior
    &gt;&gt;&gt; seq.duplicate_track(&#39;kick1&#39;, newname=&#39;kick3&#39;, with_notes=False)
    &gt;&gt;&gt; len(seq[&#39;kick3&#39;].notedict)
    0
    ```

    &#39;&#39;&#39;
    if newname is None:
        newname = unique_name(&#39;Track&#39;, self.tracknames())
    dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
    return dup</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, path, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the rendered audio to a file.
The Sequencer creates
a pydub AudioSegment which contains all Tracks overlaid,
and then uses its export method to save.</p>
<p>See the pydub documentation for more information on exporting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>system path</code></dt>
<dd>File path to save the audio to.</dd>
<dt><strong><code>overhang</code></strong> :&ensp;<code>int</code> or <code>number</code>, optional</dt>
<dd>How much extra time to render beyond the length
(i.e., the <code>beats</code>) of the Sequencer. The default is 0.
Units are either in beats or in seconds, dependent on the
<code>overhang_type</code> argument.
This can be useful when there are
notes or effects that reverberate beyond the duration of the
Sequencer.</dd>
<dt><strong><code>overhang_type</code></strong> :&ensp;<code>str -&gt; "beats"</code> or <code>"seconds"</code>, optional</dt>
<dd>Unit for the overhang. The default is 'beats'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;
    Saves the rendered audio to a file.  The Sequencer creates
    a pydub AudioSegment which contains all Tracks overlaid,
    and then uses its export method to save.

    See the pydub documentation for more information on exporting.

    Parameters
    ----------
    path : system path
        File path to save the audio to.
    overhang : int or number, optional
        How much extra time to render beyond the length
        (i.e., the `beats`) of the Sequencer. The default is 0.
        Units are either in beats or in seconds, dependent on the
        `overhang_type` argument.  This can be useful when there are
        notes or effects that reverberate beyond the duration of the
        Sequencer.
    overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
        Unit for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    _, fmt = os.path.splitext(path)
    build = self.build(overhang, overhang_type)
    build.export(path, format=fmt)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.get_track"><code class="name flex">
<span>def <span class="ident">get_track</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Track, keyed by either its name or the Track
itself (provided the Track is part of the current Sequencer).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code>str</code> or <code>Track</code></dt>
<dd>Handle for a Track to retrieve.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Track not found.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Track</code></dt>
<dd>A track that is part of this Sequencer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_track(self, track):
    &#39;&#39;&#39;
    Return a Track, keyed by either its name or the Track
    itself (provided the Track is part of the current Sequencer).

    Parameters
    ----------
    track : str or Track
        Handle for a Track to retrieve.

    Raises
    ------
    ValueError
        Track not found.

    Returns
    -------
    Track
        A track that is part of this Sequencer.

    &#39;&#39;&#39;
    if isinstance(track, str):
        try:
            return next(t for t in self._tracks if t.name == track)
        except:
            raise ValueError(f&#39;no track with name {track}&#39;)
    elif track in self._tracks:
        return track
    else:
        raise ValueError(&#39;Requested track is not part of sequencer.&#39;)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>self, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Return a looped rendering of the Sequencer.
This is akin to
<code><a title="wubwub.sequencer.Sequencer.build" href="#wubwub.sequencer.Sequencer.build">Sequencer.build()</a></code>, but the content of the Sequencer is repeated
a specified number of times.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>times</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many times to loop. The default is 4.</dd>
<dt><strong><code>internal_overhang</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Determine the length of extra time to render when the loop restarts.
This can be used to prevent abrubt shortening of sounds near the
end of the sequence. The default is 0, meaning all sounds are
cut at the end of the Sequencer length for each loop.</dd>
<dt><strong><code>end_overhang</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Determine the length of extra time to render at the of the audio,
i.e. after all loops are complete. The default is 0.</dd>
<dt><strong><code>overhang_type</code></strong> :&ensp;<code>str -&gt; 'beats'</code> or <code>'seconds'</code>, optional</dt>
<dd>Units for the overhang. The default is 'beats'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>looped</code></strong> :&ensp;<code>pydub.AudioSegment</code></dt>
<dd>The looped audio.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;
    Return a looped rendering of the Sequencer.  This is akin to
    `Sequencer.build()`, but the content of the Sequencer is repeated
    a specified number of times.

    Parameters
    ----------
    times : int, optional
        How many times to loop. The default is 4.
    internal_overhang : int or float, optional
        Determine the length of extra time to render when the loop restarts.
        This can be used to prevent abrubt shortening of sounds near the
        end of the sequence. The default is 0, meaning all sounds are
        cut at the end of the Sequencer length for each loop.
    end_overhang : int or float, optional
        Determine the length of extra time to render at the of the audio,
        i.e. after all loops are complete. The default is 0.
    overhang_type : str -&gt; &#39;beats&#39; or &#39;seconds&#39;, optional
        Units for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    looped : pydub.AudioSegment
        The looped audio.

    &#39;&#39;&#39;
    looped = loop(self, times=times, internal_overhang=internal_overhang,
                  end_overhang=end_overhang, overhang_type=overhang_type)
    return looped</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.loopplay"><code class="name flex">
<span>def <span class="ident">loopplay</span></span>(<span>self, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Calls <code><a title="wubwub.sequencer.Sequencer.play" href="#wubwub.sequencer.Sequencer.play">Sequencer.play()</a></code> on <code><a title="wubwub.sequencer.Sequencer.loop" href="#wubwub.sequencer.Sequencer.loop">Sequencer.loop()</a></code>; i.e.
immediately plays back looped audio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;Calls `Sequencer.play()` on `Sequencer.loop()`; i.e.
    immediately plays back looped audio.&#39;&#39;&#39;
    looped = loop(self, times=times, internal_overhang=internal_overhang,
                  end_overhang=end_overhang, overhang_type=overhang_type)
    play(looped)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, start=1, end=None, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"><p>Audio playback of the Sequencer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Beat to start playback on. The default is 1.</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>int</code> or <code>None</code>, optional</dt>
<dd>Beat to end playback on. The default is None.</dd>
<dt><strong><code>overhang</code></strong> :&ensp;<code>int</code> or <code>number</code>, optional</dt>
<dd>How much extra time to render beyond the length
(i.e., the <code>beats</code>) of the Sequencer. The default is 0.
Units are either in beats or in seconds, dependent on the
<code>overhang_type</code> argument.
This can be useful when there are
notes or effects that reverberate beyond the duration of the
Sequencer.</dd>
<dt><strong><code>overhang_type</code></strong> :&ensp;<code>str -&gt; "beats"</code> or <code>"seconds"</code>, optional</dt>
<dd>Unit for the overhang. The default is 'beats'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
    &#39;&#39;&#39;
    Audio playback of the Sequencer.

    Parameters
    ----------
    start : int, optional
        Beat to start playback on. The default is 1.
    end : int or None, optional
        Beat to end playback on. The default is None.
    overhang : int or number, optional
        How much extra time to render beyond the length
        (i.e., the `beats`) of the Sequencer. The default is 0.
        Units are either in beats or in seconds, dependent on the
        `overhang_type` argument.  This can be useful when there are
        notes or effects that reverberate beyond the duration of the
        Sequencer.
    overhang_type : str -&gt; &#34;beats&#34; or &#34;seconds&#34;, optional
        Unit for the overhang. The default is &#39;beats&#39;.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    b = (1/self.bpm) * MINUTE
    start = (start-1) * b
    if end is not None:
        end = (end-1) * b
    build = self.build(overhang, overhang_type)
    play(build[start:end])</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, timesig=4, grid=True, ax=None, scatter_kwds=None, plot_kwds=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="wubwub.plots.sequencerplot" href="plots.html#wubwub.plots.sequencerplot">sequencerplot()</a></code> for this Sequencer.</p>
<p>timesig : int, optional
Sets the ticks/grid to a given frequency of beats. The default is 4.
grid : bool, optional
Whether to include a grid. The default is True.
ax : matplotlib.axes.Axes, optional
Axes to create the plot on. The default is None.
scatter_kwds : dict, optional
Keyword arguments passed to <code>matplotlib.axes.Axes.scatter</code>.
The default is None.
plot_kwds : dict, optional
Keyword arguments passed to <code>matplotlib.axes.Axes.plot</code>.
The default is None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.figure.Figure</code></dt>
<dd>The Figure containing the axes used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
         plot_kwds=None):
    &#39;&#39;&#39;
    Run `wubwub.plots.sequencerplot()` for this Sequencer.

    timesig : int, optional
        Sets the ticks/grid to a given frequency of beats. The default is 4.
    grid : bool, optional
        Whether to include a grid. The default is True.
    ax : matplotlib.axes.Axes, optional
        Axes to create the plot on. The default is None.
    scatter_kwds : dict, optional
        Keyword arguments passed to `matplotlib.axes.Axes.scatter`.
        The default is None.
    plot_kwds : dict, optional
        Keyword arguments passed to `matplotlib.axes.Axes.plot`.
        The default is None.

    Returns
    -------
    matplotlib.figure.Figure
        The Figure containing the axes used.

    &#39;&#39;&#39;
    return sequencerplot(self,
                         timesig=timesig,
                         grid=grid,
                         ax=ax,
                         scatter_kwds=scatter_kwds,
                         plot_kwds=plot_kwds)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.postprocess"><code class="name flex">
<span>def <span class="ident">postprocess</span></span>(<span>self, build)</span>
</code></dt>
<dd>
<div class="desc"><p>Add postprocessing to a rendered audio output of the Sequencer,
typically that of <code><a title="wubwub.sequencer.Sequencer.build" href="#wubwub.sequencer.Sequencer.build">Sequencer.build()</a></code>.
There are currently 3
postprocessing steps applied, corresponding to 3 attributes of
the Sequencer:</p>
<ul>
<li><code>effects</code>: This attribute can be set to a pysndfx
AudioEffectsChain instance to add audio effects (such as reverb,
delay, overdrive, etc.) See
<a href="https://github.com/carlthome/python-audio-effects">here</a> for more
documentation.</li>
<li><code>volume</code>: This attribute can be set to modify the output volume
of the build.
Note that the value reflects a relative change in
dB, so values can be positive or negative.</li>
<li><code>pan</code>: a value between <code>-1.0</code> (100% left) and <code>+1.0</code> (100% right)
indicating the stereo panning (<code>0.0</code> is centered).</li>
</ul>
<p>The order/presence of these processing steps can be determined by
setting the <code>postprocess_steps</code> attribute, which should be a list
containing some subset of the strings <code>'effects'</code>, <code>'volume'</code>, and
<code>'pan</code>' (corresponding to each of the three steps above).
The default
is <code>self.postprocess_steps = ['effects', 'volume', 'pan']</code>.
<em>Omitted
steps in this attribute will not be applied, while repeated steps
will be applied multiple times.</em>
Additionally, the steps are applied
in the order encountered in <code>self.postprocess_steps</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>build</code></strong> :&ensp;<code>pydub AudioSegment</code></dt>
<dd>Audio to postprocess, typically output of <code><a title="wubwub.sequencer.Sequencer.build" href="#wubwub.sequencer.Sequencer.build">Sequencer.build()</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>build</code></strong> :&ensp;<code>pydub AudioSegment</code></dt>
<dd>Audio with postprocessing steps applied.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocess(self, build):
    &#39;&#39;&#39;
    Add postprocessing to a rendered audio output of the Sequencer,
    typically that of `Sequencer.build()`.  There are currently 3
    postprocessing steps applied, corresponding to 3 attributes of
    the Sequencer:

    - `effects`: This attribute can be set to a pysndfx
    AudioEffectsChain instance to add audio effects (such as reverb,
    delay, overdrive, etc.) See
    [here](https://github.com/carlthome/python-audio-effects) for more
    documentation.
    - `volume`: This attribute can be set to modify the output volume
    of the build.  Note that the value reflects a relative change in
    dB, so values can be positive or negative.
    - `pan`: a value between `-1.0` (100% left) and `+1.0` (100% right)
    indicating the stereo panning (`0.0` is centered).

    The order/presence of these processing steps can be determined by
    setting the `postprocess_steps` attribute, which should be a list
    containing some subset of the strings `&#39;effects&#39;`, `&#39;volume&#39;`, and
    `&#39;pan`&#39; (corresponding to each of the three steps above).  The default
    is `self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]`.  *Omitted
    steps in this attribute will not be applied, while repeated steps
    will be applied multiple times.*  Additionally, the steps are applied
    in the order encountered in `self.postprocess_steps`.

    Parameters
    ----------
    build : pydub AudioSegment
        Audio to postprocess, typically output of `Sequencer.build()`

    Returns
    -------
    build : pydub AudioSegment
        Audio with postprocessing steps applied.

    &#39;&#39;&#39;
    for step in self.postprocess_steps:
        if step == &#39;effects&#39;:
            build = add_effects(build, self.effects)
        if step == &#39;volume&#39;:
            build += self.volume
        if step == &#39;pan&#39;:
            build = build.pan(self.pan)
    return build</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.set_beats_and_clean"><code class="name flex">
<span>def <span class="ident">set_beats_and_clean</span></span>(<span>self, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the Sequencer length while simultaneously removing notes
that are outside of the sequence after the change.
I.e., sets
<code>beats</code> and calls <code><a title="wubwub.tracks.Track.clean" href="tracks.html#wubwub.tracks.Track.clean">Track.clean()</a></code> for
all tracks.
This is a convenience method which is only useful when
shortening the sequence length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code>int</code></dt>
<dd>New value for the length of the Sequencer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_beats_and_clean(self, new):
    &#34;&#34;&#34;
    Modifies the Sequencer length while simultaneously removing notes
    that are outside of the sequence after the change.  I.e., sets
    &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks.Track.clean()` for
    all tracks.  This is a convenience method which is only useful when
    shortening the sequence length.

    Parameters
    ----------
    new : int
        New value for the length of the Sequencer.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self.beats = new
    for track in self.tracks():
        track.clean()</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, printout=True, name_cutoff=None, resolution=1, singlenote='■', multinote='■', empty='□', wrap=32)</span>
</code></dt>
<dd>
<div class="desc"><p>Print (or return) a sequencer grid diagram, showing when
each Track contains notes.
For more information, see
<code><a title="wubwub.seqstring.seqstring" href="seqstring.html#wubwub.seqstring.seqstring">seqstring()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>printout</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>When True (default), print the diagram.
When False,
return the string.</dd>
<dt><strong><code>name_cutoff</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of characters to allow track names to be. The default is None.</dd>
<dt><strong><code>resolution</code></strong> :&ensp;<code>int</code> or <code>float</code>, optional</dt>
<dd>Determines the frequency of beats to use. The default is 1.</dd>
<dt><strong><code>singlenote</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Character to use for beats containing single Notes. The default is '■'.</dd>
<dt><strong><code>multinote</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Character to use for beats containing multiple notes. The default is '■'.</dd>
<dt><strong><code>empty</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Character to use for beats not containing notes. The default is '□'.</dd>
<dt><strong><code>wrap</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>How many beats (as determined by <code>resolution</code>) to show on a single line.
The default is 32.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>s (str)</code> or <code>None</code></dt>
<dd>The string diagram is returned if <code>printout</code> is <code>False</code>, otherwise
it is printed and <code>None</code> is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, printout=True, name_cutoff=None, resolution=1,
         singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
    &#39;&#39;&#39;
    Print (or return) a sequencer grid diagram, showing when
    each Track contains notes.  For more information, see
    `wubwub.seqstring.seqstring()`.

    Parameters
    ----------
    printout : bool, optional
        When True (default), print the diagram.  When False,
        return the string.
    name_cutoff : int, optional
        Number of characters to allow track names to be. The default is None.
    resolution : int or float, optional
        Determines the frequency of beats to use. The default is 1.
    singlenote : str, optional
        Character to use for beats containing single Notes. The default is &#39;■&#39;.
    multinote : str, optional
        Character to use for beats containing multiple notes. The default is &#39;■&#39;.
    empty : str, optional
        Character to use for beats not containing notes. The default is &#39;□&#39;.
    wrap : int, optional
        How many beats (as determined by `resolution`) to show on a single line.
        The default is 32.

    Returns
    -------
    s (str) or None
        The string diagram is returned if `printout` is `False`, otherwise
        it is printed and `None` is returned.

    &#39;&#39;&#39;
    s = seqstring(self,
                  name_cutoff=name_cutoff,
                  resolution=resolution,
                  singlenote=singlenote,
                  multinote=multinote,
                  empty=empty,
                  wrap=wrap)
    if printout:
        print(s)
    else:
        return s</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, selection=None, postprocess=True, gap=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Calls the sound test method for each Track in the Sequencer; i.e.
plays back all the samples being used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soundtest(self, selection=None, postprocess=True, gap=.5):
    &#39;&#39;&#39;Calls the sound test method for each Track in the Sequencer; i.e.
    plays back all the samples being used.&#39;&#39;&#39;
    if selection is None:
        selection = self.tracks()
    else:
        selection = [self.get_track(i) for i in selection]

    for track in selection:
        print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
        time.sleep(.25)
        track.soundtest(postprocess=postprocess)
        time.sleep(gap)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, beat)</span>
</code></dt>
<dd>
<div class="desc"><p>Split the Sequencer into two new Sequencers at a given beat.
The objects
returned are <em>new Sequencers</em> (generated by <code><a title="wubwub.sequencer.Sequencer.copy" href="#wubwub.sequencer.Sequencer.copy">Sequencer.copy()</a></code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>beat</code></strong> :&ensp;<code>int</code></dt>
<dd>The beat to split the Sequencer on.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>Non-integer beat is passed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>a</code></strong>, <strong><code>b</code></strong> :&ensp;<code><a title="wubwub.sequencer.Sequencer" href="#wubwub.sequencer.Sequencer">Sequencer</a></code></dt>
<dd>Two new Sequencers.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb
&gt;&gt;&gt; import wubwub.sounds as snd

# make a sequencer and add tracks/notes
&gt;&gt;&gt; seq = wb.Sequencer(beats=8, bpm=100)
&gt;&gt;&gt; drums = snd.load('drums.808')
&gt;&gt;&gt; kick = seq.add_sampler(drums['kick1'], name='kick')
&gt;&gt;&gt; snare = seq.add_sampler(drums['snare'], name='snare')
&gt;&gt;&gt; kick.make_notes_every(2)
&gt;&gt;&gt; snare.make_notes_every(2, offset=1)
&gt;&gt;&gt; seq.show()
      1 2 3 4 5 6 7 8
 kick ■ □ ■ □ ■ □ ■ □
snare □ ■ □ ■ □ ■ □ ■

# split
&gt;&gt;&gt; a, b = seq.split(4)

# show
&gt;&gt;&gt; a.show()
      1 2 3
 kick ■ □ ■
snare □ ■ □

&gt;&gt;&gt; b.show()
      1 2 3 4 5
 kick □ ■ □ ■ □
snare ■ □ ■ □ ■
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, beat):
    &#39;&#39;&#39;
    Split the Sequencer into two new Sequencers at a given beat.  The objects
    returned are *new Sequencers* (generated by `Sequencer.copy()`).

    Parameters
    ----------
    beat : int
        The beat to split the Sequencer on.

    Raises
    ------
    TypeError
        Non-integer beat is passed.

    Returns
    -------
    a, b : wubwub.sequencer.Sequencer
        Two new Sequencers.

    Examples
    --------
    ```python
    &gt;&gt;&gt; import wubwub as wb
    &gt;&gt;&gt; import wubwub.sounds as snd

    # make a sequencer and add tracks/notes
    &gt;&gt;&gt; seq = wb.Sequencer(beats=8, bpm=100)
    &gt;&gt;&gt; drums = snd.load(&#39;drums.808&#39;)
    &gt;&gt;&gt; kick = seq.add_sampler(drums[&#39;kick1&#39;], name=&#39;kick&#39;)
    &gt;&gt;&gt; snare = seq.add_sampler(drums[&#39;snare&#39;], name=&#39;snare&#39;)
    &gt;&gt;&gt; kick.make_notes_every(2)
    &gt;&gt;&gt; snare.make_notes_every(2, offset=1)
    &gt;&gt;&gt; seq.show()
          1 2 3 4 5 6 7 8
     kick ■ □ ■ □ ■ □ ■ □
    snare □ ■ □ ■ □ ■ □ ■

    # split
    &gt;&gt;&gt; a, b = seq.split(4)

    # show
    &gt;&gt;&gt; a.show()
          1 2 3
     kick ■ □ ■
    snare □ ■ □

    &gt;&gt;&gt; b.show()
          1 2 3 4 5
     kick □ ■ □ ■ □
    snare ■ □ ■ □ ■
    ```

    &#39;&#39;&#39;
    if not isinstance(beat, int):
        raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

    a1, a2 = (1, beat)
    b1, b2 = (beat, self.beats+1)

    a = self.copy(with_notes=False)
    a.beats = a2 - a1
    b = self.copy(with_notes=False)
    b.beats = b2 - b1

    for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
        anotes = selftrack.slice[a1:a2]
        atrack.add_fromdict(anotes)
        bnotes = selftrack.slice[b1:b2]
        btrack.add_fromdict(bnotes, offset=(-beat + 1))

    return a, b</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.tracknames"><code class="name flex">
<span>def <span class="ident">tracknames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the names of each Track currenlty part of this Sequencer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracknames(self):
    &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
    return [t.name for t in self._tracks]</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.tracks"><code class="name flex">
<span>def <span class="ident">tracks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of the Track objects currently part of this Sequencer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracks(self):
    &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
    return tuple(self._tracks)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="wubwub Home" href="https://github.com/earnestt1234/wubwub/">
<img src="https://raw.githubusercontent.com/earnestt1234/wubwub/main/img/logo.png" alt="">
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wubwub" href="index.html">wubwub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wubwub.sequencer.join" href="#wubwub.sequencer.join">join</a></code></li>
<li><code><a title="wubwub.sequencer.loop" href="#wubwub.sequencer.loop">loop</a></code></li>
<li><code><a title="wubwub.sequencer.stitch" href="#wubwub.sequencer.stitch">stitch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wubwub.sequencer.Sequencer" href="#wubwub.sequencer.Sequencer">Sequencer</a></code></h4>
<ul class="two-column">
<li><code><a title="wubwub.sequencer.Sequencer.add_arpeggiator" href="#wubwub.sequencer.Sequencer.add_arpeggiator">add_arpeggiator</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_multisampler" href="#wubwub.sequencer.Sequencer.add_multisampler">add_multisampler</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_sampler" href="#wubwub.sequencer.Sequencer.add_sampler">add_sampler</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_samplers" href="#wubwub.sequencer.Sequencer.add_samplers">add_samplers</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.build" href="#wubwub.sequencer.Sequencer.build">build</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.copy" href="#wubwub.sequencer.Sequencer.copy">copy</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.copypaste_section" href="#wubwub.sequencer.Sequencer.copypaste_section">copypaste_section</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.delete_track" href="#wubwub.sequencer.Sequencer.delete_track">delete_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.duplicate_track" href="#wubwub.sequencer.Sequencer.duplicate_track">duplicate_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.export" href="#wubwub.sequencer.Sequencer.export">export</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.get_track" href="#wubwub.sequencer.Sequencer.get_track">get_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.loop" href="#wubwub.sequencer.Sequencer.loop">loop</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.loopplay" href="#wubwub.sequencer.Sequencer.loopplay">loopplay</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.play" href="#wubwub.sequencer.Sequencer.play">play</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.plot" href="#wubwub.sequencer.Sequencer.plot">plot</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.postprocess" href="#wubwub.sequencer.Sequencer.postprocess">postprocess</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.set_beats_and_clean" href="#wubwub.sequencer.Sequencer.set_beats_and_clean">set_beats_and_clean</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.show" href="#wubwub.sequencer.Sequencer.show">show</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.soundtest" href="#wubwub.sequencer.Sequencer.soundtest">soundtest</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.split" href="#wubwub.sequencer.Sequencer.split">split</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.tracknames" href="#wubwub.sequencer.Sequencer.tracknames">tracknames</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.tracks" href="#wubwub.sequencer.Sequencer.tracks">tracks</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>