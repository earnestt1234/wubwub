<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>wubwub.sequencer API documentation</title>
<meta name="description" content="This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>wubwub.sequencer</code></h1>
</header>
<section id="section-intro">
<p>This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module contains the Sequencer class, and associated functions for
working with Sequencers in wubwub.
&#34;&#34;&#34;

from copy import copy
import os
import time

import pydub

from wubwub.audio import add_effects, play, _overhang_to_milli
from wubwub.errors import WubWubError
from wubwub.plots import sequencerplot
from wubwub.resources import MINUTE, unique_name
from wubwub.seqstring import seqstring
from wubwub.tracks import Sampler, Arpeggiator, MultiSampler

__all__ = (&#39;Sequencer&#39;, &#39;stitch&#39;, &#39;join&#39;, &#39;loop&#39;)

class Sequencer:
    &#39;&#39;&#39;
    The Sequencer is the main tool for creating beats in wubwub.  Sequencers
    hold and organize individual instrument Tracks which can be filled
    with musical elements.  Sequencers have a defined length (and tempo), but
    multiple can be combined to create longer/varied arrangements.

    Both parameters for initialization (BPM and length) can be tweaked
    after creation by setting the value of the &lt;code&gt;bpm&lt;/code&gt; or
    &lt;code&gt;beats&lt;/code&gt; attributes.

    Parameters
    ----------
    bpm : int or float
        Tempo of the sequencer (beats per minute).
    beats : int
        The length of the sequence, in beats.

    Examples
    --------
    Initialize a Sequencer with a tempo and length:

    ```python
    &gt;&gt;&gt; import wubwub as wb
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq
    Sequencer(bpm=120, beats=8, tracks=0)

    ```
    &#39;&#39;&#39;

    def __init__(self, bpm, beats):
        &#34;&#34;&#34;Initialization function for the Sequencer.  Sets the BPM and beats
        based on user input, also defaults attributes related to post-processing
        the output audio and creates a container for subsidiary tracks.&#34;&#34;&#34;

        self.bpm = bpm
        self.beats = beats

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._tracks = []

    def __repr__(self):
        &#34;&#34;&#34;String representation of self.&#34;&#34;&#34;
        l = len(self.tracks())
        return f&#34;Sequencer(bpm={self.bpm}, beats={self.beats}, tracks={l})&#34;

    def __getitem__(self, name):
        &#34;&#34;&#34;Allows for retrieval of Track objects by their string name.&#34;&#34;&#34;
        if not isinstance(name, str):
            e = f&#39;Can only index Sequencer with str, not {type(name)}&#39;
            raise WubWubError(e)
        return self.get_track(name)

    def _add_track(self, track):
        &#34;&#34;&#34;Helper function called when adding a new track to self.  Checks for
        duplicate names, and tries to ensure non-duplicate entries of items
        in different Sequencers.&#34;&#34;&#34;
        if track.name in self.tracknames():
            raise WubWubError(f&#39;Track name &#34;{track.name}&#34; already in use.&#39;)
        if track.sequencer != self:
            track.sequencer = self
        if track not in self._tracks:
            self._tracks.append(track)

    def copypaste_section(self, start, stop, newstart):
        &#39;&#39;&#39;
        For all tracks of the Sequencer, take a section of notes and replicate
        them on a new beat (keeping the same relative spacing between notes).
        Simply, this method calls `wubwub.tracks._GenericTrack.copypaste()`
        for all tracks within the Sequencer.

        Parameters
        ----------
        start : int or float
            Beat to start copying notes (inclusive).
        stop : int or float
            Beat to stop copying notes (exlcusive).
        newstart : int or float
            Beat to paste the copied section.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for track in self.tracks():
            track.copypaste(start, stop, newstart)

    def set_beats_and_clean(self, new):
        &#34;&#34;&#34;
        Modifies the Sequencer length while simultaneously removing notes
        that are outside of the sequence after the change.  I.e., sets
        &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks._GenericTrack.clean()` for
        all tracks.  This is a convenience method which is only useful when
        shortening the sequence length.

        Parameters
        ----------
        new : int
            New value for the length of the Sequencer.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.beats = new
        for track in self.tracks():
            track.clean()

    def get_track(self, track):
        &#39;&#39;&#39;
        Return a Track, keyed by either its name or the Track
        itself (provided the Track is part of the current Sequencer).

        Parameters
        ----------
        track : str or Track
            Handle for a Track to retrieve.

        Raises
        ------
        ValueError
            Track not found.

        Returns
        -------
        Track
            A track that is part of this Sequencer.

        &#39;&#39;&#39;
        if isinstance(track, str):
            try:
                return next(t for t in self._tracks if t.name == track)
            except:
                raise ValueError(f&#39;no track with name {track}&#39;)
        elif track in self._tracks:
            return track
        else:
            raise ValueError(&#39;Requested track is not part of sequencer.&#39;)

    def tracks(self):
        &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
        return tuple(self._tracks)

    def tracknames(self):
        &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
        return [t.name for t in self._tracks]

    def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
        &#34;&#34;&#34;
        Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Sampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound
        seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

        # using a pydub.AudioSegment
        import wubwub.sounds as snd

        clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
        seq.add_sampler(clap, name=&#39;clap&#39;)
        ```

        Returns
        -------
        new : Track
            The new Track.

        &#34;&#34;&#34;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Sampler(name=name, sample=sample, overlap=overlap,
                      basepitch=basepitch, sequencer=self)
        return new

    def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                        basepitch=&#39;C4&#39;):
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Arpeggiator(name=name, sample=sample, freq=freq,
                          method=method, basepitch=basepitch,
                          sequencer=self)
        return new

    def add_multisampler(self, name=None, overlap=False):
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = MultiSampler(name=name, overlap=overlap, sequencer=self)
        return new

    def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
        if names is None:
            names = [None] * len(samples)
        for sample, name in zip(samples, names):
            self.add_sampler(sample=sample, name=name, overlap=overlap,
                             basepitch=basepitch)

    def duplicate_track(self, track, newname=None, with_notes=True):
        if newname is None:
            newname = unique_name(&#39;Track&#39;, self.tracknames())
        dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
        return dup

    def copy(self, with_notes=True):
        new = Sequencer(beats=self.beats, bpm=self.bpm)
        for track in self.tracks():
            t = track.copy(with_notes=with_notes, newseq=new)
        return new

    def split(self, beat):
        if not isinstance(beat, int):
            raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

        a1, a2 = (1, beat)
        b1, b2 = (beat, self.beats+1)

        a = self.copy(with_notes=False)
        a.beats = a2 - a1
        b = self.copy(with_notes=False)
        b.beats = b2 - b1

        for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
            anotes = selftrack.slice[a1:a2]
            atrack.add_fromdict(anotes)
            bnotes = selftrack.slice[b1:b2]
            btrack.add_fromdict(bnotes, offset=-b.beats)

        return a, b

    def delete_track(self, track):
        t = self.get_track(track)
        t.sequencer = None
        self._tracks.remove(t)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.bpm) * MINUTE
        seq_oh = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.beats * b + seq_oh
        audio = pydub.AudioSegment.silent(duration=tracklength)
        for track in self.tracks():
            audio = audio.overlay(track.build(overhang, overhang_type))
        return self.postprocess(audio)

    def postprocess(self, build):
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.bpm) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        return looped

    def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        play(looped)

    def soundtest(self, selection=None, postprocess=True, gap=.5):
        if selection is None:
            selection = self.tracks()
        else:
            selection = [self.get_track(i) for i in selection]

        for track in selection:
            print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
            time.sleep(.25)
            track.soundtest(postprocess=postprocess)
            time.sleep(gap)

    def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
        _, fmt = os.path.splitext(path)
        build = self.build(overhang, overhang_type)
        build.export(path, format=fmt)

    def show(self, printout=True, name_cutoff=None, resolution=1,
             singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
        s = seqstring(self,
                      name_cutoff=name_cutoff,
                      resolution=resolution,
                      singlenote=singlenote,
                      multinote=multinote,
                      empty=empty,
                      wrap=wrap)
        if printout:
            print(s)
        else:
            return s

    def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
             plot_kwds=None):
        sequencerplot(self,
                      timesig=timesig,
                      grid=grid,
                      ax=ax,
                      scatter_kwds=scatter_kwds,
                      plot_kwds=plot_kwds)


def stitch(sequencers, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    total_length = 0
    current = 0
    sectionstarts = []
    for seq in sequencers:
        b = (1/seq.bpm) * MINUTE
        seq_length = b * seq.beats
        total_length += seq_length
        sectionstarts.append(current)
        current += seq_length
    total_length += _overhang_to_milli(end_overhang, overhang_type, b)

    stitched = pydub.AudioSegment.silent(duration=total_length)
    for start, seq in zip(sectionstarts, sequencers):
        build = seq.build(internal_overhang, overhang_type)
        stitched = stitched.overlay(build, start)

    return stitched

def _matchesforjoin(oldtracks, newtrack, on=&#39;name&#39;):
    ons = [&#39;name&#39;, &#39;sample&#39;, &#39;sample+type&#39;]
    if on not in ons:
        raise WubWubError(f&#39;`on` must be selected from {ons}&#39;)

    if on == &#39;name&#39;:
        return [track for track in oldtracks if track.name == newtrack.name]
    if on == &#39;sample&#39;:
        return [track for track in oldtracks if track.sample == newtrack.sample]
    if on == &#39;sample+type&#39;:
        return [track for track in oldtracks if track.sample == newtrack.sample
                and type(track) == type(newtrack)]
    return []

def join(sequencers, on=&#39;name&#39;):
    beats = sum(seq.beats for seq in sequencers)
    out = Sequencer(bpm=sequencers[0].bpm, beats=beats)
    offset = 0
    for i, seq in enumerate(sequencers):
        oldtracks = out.tracks()
        available = list(oldtracks)

        for track in seq.tracks():
            match = None
            matches = _matchesforjoin(available, track, on=on)
            if matches:
                match = matches[0]
                available.remove(match)

            if match:
                match.add_fromdict(track.notedict, offset=offset)

            else:
                new = track.copy(with_notes=False, newseq=out)
                new.add_fromdict(track.notedict, offset=offset)


        offset = seq.beats
    return out

def loop(sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):

    return stitch([sequencer] * times,
                  internal_overhang,
                  end_overhang,
                  overhang_type)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="wubwub.sequencer.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>sequencers, on='name')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(sequencers, on=&#39;name&#39;):
    beats = sum(seq.beats for seq in sequencers)
    out = Sequencer(bpm=sequencers[0].bpm, beats=beats)
    offset = 0
    for i, seq in enumerate(sequencers):
        oldtracks = out.tracks()
        available = list(oldtracks)

        for track in seq.tracks():
            match = None
            matches = _matchesforjoin(available, track, on=on)
            if matches:
                match = matches[0]
                available.remove(match)

            if match:
                match.add_fromdict(track.notedict, offset=offset)

            else:
                new = track.copy(with_notes=False, newseq=out)
                new.add_fromdict(track.notedict, offset=offset)


        offset = seq.beats
    return out</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(sequencer, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):

    return stitch([sequencer] * times,
                  internal_overhang,
                  end_overhang,
                  overhang_type)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.stitch"><code class="name flex">
<span>def <span class="ident">stitch</span></span>(<span>sequencers, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stitch(sequencers, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    total_length = 0
    current = 0
    sectionstarts = []
    for seq in sequencers:
        b = (1/seq.bpm) * MINUTE
        seq_length = b * seq.beats
        total_length += seq_length
        sectionstarts.append(current)
        current += seq_length
    total_length += _overhang_to_milli(end_overhang, overhang_type, b)

    stitched = pydub.AudioSegment.silent(duration=total_length)
    for start, seq in zip(sectionstarts, sequencers):
        build = seq.build(internal_overhang, overhang_type)
        stitched = stitched.overlay(build, start)

    return stitched</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="wubwub.sequencer.Sequencer"><code class="flex name class">
<span>class <span class="ident">Sequencer</span></span>
<span>(</span><span>bpm, beats)</span>
</code></dt>
<dd>
<div class="desc"><p>The Sequencer is the main tool for creating beats in wubwub.
Sequencers
hold and organize individual instrument Tracks which can be filled
with musical elements.
Sequencers have a defined length (and tempo), but
multiple can be combined to create longer/varied arrangements.</p>
<p>Both parameters for initialization (BPM and length) can be tweaked
after creation by setting the value of the <code>bpm</code> or
<code>beats</code> attributes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>bpm</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Tempo of the sequencer (beats per minute).</dd>
<dt><strong><code>beats</code></strong> :&ensp;<code>int</code></dt>
<dd>The length of the sequence, in beats.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Initialize a Sequencer with a tempo and length:</p>
<pre><code class="python">&gt;&gt;&gt; import wubwub as wb
&gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
&gt;&gt;&gt; seq
Sequencer(bpm=120, beats=8, tracks=0)

</code></pre>
<p>Initialization function for the Sequencer.
Sets the BPM and beats
based on user input, also defaults attributes related to post-processing
the output audio and creates a container for subsidiary tracks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sequencer:
    &#39;&#39;&#39;
    The Sequencer is the main tool for creating beats in wubwub.  Sequencers
    hold and organize individual instrument Tracks which can be filled
    with musical elements.  Sequencers have a defined length (and tempo), but
    multiple can be combined to create longer/varied arrangements.

    Both parameters for initialization (BPM and length) can be tweaked
    after creation by setting the value of the &lt;code&gt;bpm&lt;/code&gt; or
    &lt;code&gt;beats&lt;/code&gt; attributes.

    Parameters
    ----------
    bpm : int or float
        Tempo of the sequencer (beats per minute).
    beats : int
        The length of the sequence, in beats.

    Examples
    --------
    Initialize a Sequencer with a tempo and length:

    ```python
    &gt;&gt;&gt; import wubwub as wb
    &gt;&gt;&gt; seq = wb.Sequencer(bpm=120, beats=8)
    &gt;&gt;&gt; seq
    Sequencer(bpm=120, beats=8, tracks=0)

    ```
    &#39;&#39;&#39;

    def __init__(self, bpm, beats):
        &#34;&#34;&#34;Initialization function for the Sequencer.  Sets the BPM and beats
        based on user input, also defaults attributes related to post-processing
        the output audio and creates a container for subsidiary tracks.&#34;&#34;&#34;

        self.bpm = bpm
        self.beats = beats

        self.effects = None
        self.volume = 0
        self.pan = 0
        self.postprocess_steps = [&#39;effects&#39;, &#39;volume&#39;, &#39;pan&#39;]

        self._tracks = []

    def __repr__(self):
        &#34;&#34;&#34;String representation of self.&#34;&#34;&#34;
        l = len(self.tracks())
        return f&#34;Sequencer(bpm={self.bpm}, beats={self.beats}, tracks={l})&#34;

    def __getitem__(self, name):
        &#34;&#34;&#34;Allows for retrieval of Track objects by their string name.&#34;&#34;&#34;
        if not isinstance(name, str):
            e = f&#39;Can only index Sequencer with str, not {type(name)}&#39;
            raise WubWubError(e)
        return self.get_track(name)

    def _add_track(self, track):
        &#34;&#34;&#34;Helper function called when adding a new track to self.  Checks for
        duplicate names, and tries to ensure non-duplicate entries of items
        in different Sequencers.&#34;&#34;&#34;
        if track.name in self.tracknames():
            raise WubWubError(f&#39;Track name &#34;{track.name}&#34; already in use.&#39;)
        if track.sequencer != self:
            track.sequencer = self
        if track not in self._tracks:
            self._tracks.append(track)

    def copypaste_section(self, start, stop, newstart):
        &#39;&#39;&#39;
        For all tracks of the Sequencer, take a section of notes and replicate
        them on a new beat (keeping the same relative spacing between notes).
        Simply, this method calls `wubwub.tracks._GenericTrack.copypaste()`
        for all tracks within the Sequencer.

        Parameters
        ----------
        start : int or float
            Beat to start copying notes (inclusive).
        stop : int or float
            Beat to stop copying notes (exlcusive).
        newstart : int or float
            Beat to paste the copied section.

        Returns
        -------
        None.

        &#39;&#39;&#39;
        for track in self.tracks():
            track.copypaste(start, stop, newstart)

    def set_beats_and_clean(self, new):
        &#34;&#34;&#34;
        Modifies the Sequencer length while simultaneously removing notes
        that are outside of the sequence after the change.  I.e., sets
        &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks._GenericTrack.clean()` for
        all tracks.  This is a convenience method which is only useful when
        shortening the sequence length.

        Parameters
        ----------
        new : int
            New value for the length of the Sequencer.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self.beats = new
        for track in self.tracks():
            track.clean()

    def get_track(self, track):
        &#39;&#39;&#39;
        Return a Track, keyed by either its name or the Track
        itself (provided the Track is part of the current Sequencer).

        Parameters
        ----------
        track : str or Track
            Handle for a Track to retrieve.

        Raises
        ------
        ValueError
            Track not found.

        Returns
        -------
        Track
            A track that is part of this Sequencer.

        &#39;&#39;&#39;
        if isinstance(track, str):
            try:
                return next(t for t in self._tracks if t.name == track)
            except:
                raise ValueError(f&#39;no track with name {track}&#39;)
        elif track in self._tracks:
            return track
        else:
            raise ValueError(&#39;Requested track is not part of sequencer.&#39;)

    def tracks(self):
        &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
        return tuple(self._tracks)

    def tracknames(self):
        &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
        return [t.name for t in self._tracks]

    def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
        &#34;&#34;&#34;
        Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
        Parameters here are initialization values for `wubwub.tracks.Sampler`;
        see there for more detailed documentation.

        Parameters
        ----------
        sample : path or pydub.AudioSegment
            Sample for Sampler initialization.
        name : str, optional
            Name for the new Sampler.
        overlap : bool, optional
            Set the overlap behavior of the new Sampler. The default is False.
        basepitch : int or str, optional
            Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

        Examples
        --------
        ```python
        import wubwub as wb

        seq = wb.Sequencer(bpm=100, beats=16)

        # path to sound
        seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

        # using a pydub.AudioSegment
        import wubwub.sounds as snd

        clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
        seq.add_sampler(clap, name=&#39;clap&#39;)
        ```

        Returns
        -------
        new : Track
            The new Track.

        &#34;&#34;&#34;
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Sampler(name=name, sample=sample, overlap=overlap,
                      basepitch=basepitch, sequencer=self)
        return new

    def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                        basepitch=&#39;C4&#39;):
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = Arpeggiator(name=name, sample=sample, freq=freq,
                          method=method, basepitch=basepitch,
                          sequencer=self)
        return new

    def add_multisampler(self, name=None, overlap=False):
        if name is None:
            name = unique_name(&#39;Track&#39;, self.tracknames())
        new = MultiSampler(name=name, overlap=overlap, sequencer=self)
        return new

    def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
        if names is None:
            names = [None] * len(samples)
        for sample, name in zip(samples, names):
            self.add_sampler(sample=sample, name=name, overlap=overlap,
                             basepitch=basepitch)

    def duplicate_track(self, track, newname=None, with_notes=True):
        if newname is None:
            newname = unique_name(&#39;Track&#39;, self.tracknames())
        dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
        return dup

    def copy(self, with_notes=True):
        new = Sequencer(beats=self.beats, bpm=self.bpm)
        for track in self.tracks():
            t = track.copy(with_notes=with_notes, newseq=new)
        return new

    def split(self, beat):
        if not isinstance(beat, int):
            raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

        a1, a2 = (1, beat)
        b1, b2 = (beat, self.beats+1)

        a = self.copy(with_notes=False)
        a.beats = a2 - a1
        b = self.copy(with_notes=False)
        b.beats = b2 - b1

        for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
            anotes = selftrack.slice[a1:a2]
            atrack.add_fromdict(anotes)
            bnotes = selftrack.slice[b1:b2]
            btrack.add_fromdict(bnotes, offset=-b.beats)

        return a, b

    def delete_track(self, track):
        t = self.get_track(track)
        t.sequencer = None
        self._tracks.remove(t)

    def build(self, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.bpm) * MINUTE
        seq_oh = _overhang_to_milli(overhang, overhang_type, b)
        tracklength = self.beats * b + seq_oh
        audio = pydub.AudioSegment.silent(duration=tracklength)
        for track in self.tracks():
            audio = audio.overlay(track.build(overhang, overhang_type))
        return self.postprocess(audio)

    def postprocess(self, build):
        for step in self.postprocess_steps:
            if step == &#39;effects&#39;:
                build = add_effects(build, self.effects)
            if step == &#39;volume&#39;:
                build += self.volume
            if step == &#39;pan&#39;:
                build = build.pan(self.pan)
        return build

    def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
        b = (1/self.bpm) * MINUTE
        start = (start-1) * b
        if end is not None:
            end = (end-1) * b
        build = self.build(overhang, overhang_type)
        play(build[start:end])

    def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        return looped

    def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
        looped = loop(self, times=times, internal_overhang=internal_overhang,
                      end_overhang=end_overhang, overhang_type=overhang_type)
        play(looped)

    def soundtest(self, selection=None, postprocess=True, gap=.5):
        if selection is None:
            selection = self.tracks()
        else:
            selection = [self.get_track(i) for i in selection]

        for track in selection:
            print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
            time.sleep(.25)
            track.soundtest(postprocess=postprocess)
            time.sleep(gap)

    def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
        _, fmt = os.path.splitext(path)
        build = self.build(overhang, overhang_type)
        build.export(path, format=fmt)

    def show(self, printout=True, name_cutoff=None, resolution=1,
             singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
        s = seqstring(self,
                      name_cutoff=name_cutoff,
                      resolution=resolution,
                      singlenote=singlenote,
                      multinote=multinote,
                      empty=empty,
                      wrap=wrap)
        if printout:
            print(s)
        else:
            return s

    def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
             plot_kwds=None):
        sequencerplot(self,
                      timesig=timesig,
                      grid=grid,
                      ax=ax,
                      scatter_kwds=scatter_kwds,
                      plot_kwds=plot_kwds)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="wubwub.sequencer.Sequencer.add_arpeggiator"><code class="name flex">
<span>def <span class="ident">add_arpeggiator</span></span>(<span>self, sample, name=None, freq=0.5, method='up', basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_arpeggiator(self, sample, name=None, freq=0.5, method=&#39;up&#39;,
                    basepitch=&#39;C4&#39;):
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = Arpeggiator(name=name, sample=sample, freq=freq,
                      method=method, basepitch=basepitch,
                      sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_multisampler"><code class="name flex">
<span>def <span class="ident">add_multisampler</span></span>(<span>self, name=None, overlap=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_multisampler(self, name=None, overlap=False):
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = MultiSampler(name=name, overlap=overlap, sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_sampler"><code class="name flex">
<span>def <span class="ident">add_sampler</span></span>(<span>self, sample, name=None, overlap=False, basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code> Track and add to the Sequencer.
Parameters here are initialization values for <code><a title="wubwub.tracks.Sampler" href="tracks.html#wubwub.tracks.Sampler">Sampler</a></code>;
see there for more detailed documentation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sample</code></strong> :&ensp;<code>path</code> or <code>pydub.AudioSegment</code></dt>
<dd>Sample for Sampler initialization.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name for the new Sampler.</dd>
<dt><strong><code>overlap</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set the overlap behavior of the new Sampler. The default is False.</dd>
<dt><strong><code>basepitch</code></strong> :&ensp;<code>int</code> or <code>str</code>, optional</dt>
<dd>Set the base pitch for the new Sampler. The default is 'C4'.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python">import wubwub as wb

seq = wb.Sequencer(bpm=100, beats=16)

# path to sound
seq.add_sampler('my_kick.wav', name='kick')

# using a pydub.AudioSegment
import wubwub.sounds as snd

clap = snd.load('drums.808')['handclap']
seq.add_sampler(clap, name='clap')
</code></pre>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code>Track</code></dt>
<dd>The new Track.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_sampler(self, sample, name=None, overlap=False, basepitch=&#39;C4&#39;):
    &#34;&#34;&#34;
    Create a new `wubwub.tracks.Sampler` Track and add to the Sequencer.
    Parameters here are initialization values for `wubwub.tracks.Sampler`;
    see there for more detailed documentation.

    Parameters
    ----------
    sample : path or pydub.AudioSegment
        Sample for Sampler initialization.
    name : str, optional
        Name for the new Sampler.
    overlap : bool, optional
        Set the overlap behavior of the new Sampler. The default is False.
    basepitch : int or str, optional
        Set the base pitch for the new Sampler. The default is &#39;C4&#39;.

    Examples
    --------
    ```python
    import wubwub as wb

    seq = wb.Sequencer(bpm=100, beats=16)

    # path to sound
    seq.add_sampler(&#39;my_kick.wav&#39;, name=&#39;kick&#39;)

    # using a pydub.AudioSegment
    import wubwub.sounds as snd

    clap = snd.load(&#39;drums.808&#39;)[&#39;handclap&#39;]
    seq.add_sampler(clap, name=&#39;clap&#39;)
    ```

    Returns
    -------
    new : Track
        The new Track.

    &#34;&#34;&#34;
    if name is None:
        name = unique_name(&#39;Track&#39;, self.tracknames())
    new = Sampler(name=name, sample=sample, overlap=overlap,
                  basepitch=basepitch, sequencer=self)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.add_samplers"><code class="name flex">
<span>def <span class="ident">add_samplers</span></span>(<span>self, samples, names=None, overlap=False, basepitch='C4')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_samplers(self, samples, names=None, overlap=False, basepitch=&#39;C4&#39;):
    if names is None:
        names = [None] * len(samples)
    for sample, name in zip(samples, names):
        self.add_sampler(sample=sample, name=name, overlap=overlap,
                         basepitch=basepitch)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.bpm) * MINUTE
    seq_oh = _overhang_to_milli(overhang, overhang_type, b)
    tracklength = self.beats * b + seq_oh
    audio = pydub.AudioSegment.silent(duration=tracklength)
    for track in self.tracks():
        audio = audio.overlay(track.build(overhang, overhang_type))
    return self.postprocess(audio)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, with_notes=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self, with_notes=True):
    new = Sequencer(beats=self.beats, bpm=self.bpm)
    for track in self.tracks():
        t = track.copy(with_notes=with_notes, newseq=new)
    return new</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.copypaste_section"><code class="name flex">
<span>def <span class="ident">copypaste_section</span></span>(<span>self, start, stop, newstart)</span>
</code></dt>
<dd>
<div class="desc"><p>For all tracks of the Sequencer, take a section of notes and replicate
them on a new beat (keeping the same relative spacing between notes).
Simply, this method calls <code><a title="wubwub.tracks._GenericTrack.copypaste" href="tracks.html#wubwub.tracks._GenericTrack.copypaste">_GenericTrack.copypaste()</a></code>
for all tracks within the Sequencer.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to start copying notes (inclusive).</dd>
<dt><strong><code>stop</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to stop copying notes (exlcusive).</dd>
<dt><strong><code>newstart</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Beat to paste the copied section.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copypaste_section(self, start, stop, newstart):
    &#39;&#39;&#39;
    For all tracks of the Sequencer, take a section of notes and replicate
    them on a new beat (keeping the same relative spacing between notes).
    Simply, this method calls `wubwub.tracks._GenericTrack.copypaste()`
    for all tracks within the Sequencer.

    Parameters
    ----------
    start : int or float
        Beat to start copying notes (inclusive).
    stop : int or float
        Beat to stop copying notes (exlcusive).
    newstart : int or float
        Beat to paste the copied section.

    Returns
    -------
    None.

    &#39;&#39;&#39;
    for track in self.tracks():
        track.copypaste(start, stop, newstart)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.delete_track"><code class="name flex">
<span>def <span class="ident">delete_track</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_track(self, track):
    t = self.get_track(track)
    t.sequencer = None
    self._tracks.remove(t)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.duplicate_track"><code class="name flex">
<span>def <span class="ident">duplicate_track</span></span>(<span>self, track, newname=None, with_notes=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def duplicate_track(self, track, newname=None, with_notes=True):
    if newname is None:
        newname = unique_name(&#39;Track&#39;, self.tracknames())
    dup = self.get_track(track).copy(newname=newname, with_notes=with_notes)
    return dup</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, path, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, path, overhang=0, overhang_type=&#39;beats&#39;):
    _, fmt = os.path.splitext(path)
    build = self.build(overhang, overhang_type)
    build.export(path, format=fmt)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.get_track"><code class="name flex">
<span>def <span class="ident">get_track</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a Track, keyed by either its name or the Track
itself (provided the Track is part of the current Sequencer).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>track</code></strong> :&ensp;<code>str</code> or <code>Track</code></dt>
<dd>Handle for a Track to retrieve.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Track not found.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Track</code></dt>
<dd>A track that is part of this Sequencer.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_track(self, track):
    &#39;&#39;&#39;
    Return a Track, keyed by either its name or the Track
    itself (provided the Track is part of the current Sequencer).

    Parameters
    ----------
    track : str or Track
        Handle for a Track to retrieve.

    Raises
    ------
    ValueError
        Track not found.

    Returns
    -------
    Track
        A track that is part of this Sequencer.

    &#39;&#39;&#39;
    if isinstance(track, str):
        try:
            return next(t for t in self._tracks if t.name == track)
        except:
            raise ValueError(f&#39;no track with name {track}&#39;)
    elif track in self._tracks:
        return track
    else:
        raise ValueError(&#39;Requested track is not part of sequencer.&#39;)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.loop"><code class="name flex">
<span>def <span class="ident">loop</span></span>(<span>self, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    looped = loop(self, times=times, internal_overhang=internal_overhang,
                  end_overhang=end_overhang, overhang_type=overhang_type)
    return looped</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.loopplay"><code class="name flex">
<span>def <span class="ident">loopplay</span></span>(<span>self, times=4, internal_overhang=0, end_overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loopplay(self, times=4, internal_overhang=0, end_overhang=0, overhang_type=&#39;beats&#39;):
    looped = loop(self, times=times, internal_overhang=internal_overhang,
                  end_overhang=end_overhang, overhang_type=overhang_type)
    play(looped)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self, start=1, end=None, overhang=0, overhang_type='beats')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self, start=1, end=None, overhang=0, overhang_type=&#39;beats&#39;):
    b = (1/self.bpm) * MINUTE
    start = (start-1) * b
    if end is not None:
        end = (end-1) * b
    build = self.build(overhang, overhang_type)
    play(build[start:end])</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, timesig=4, grid=True, ax=None, scatter_kwds=None, plot_kwds=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, timesig=4, grid=True, ax=None, scatter_kwds=None,
         plot_kwds=None):
    sequencerplot(self,
                  timesig=timesig,
                  grid=grid,
                  ax=ax,
                  scatter_kwds=scatter_kwds,
                  plot_kwds=plot_kwds)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.postprocess"><code class="name flex">
<span>def <span class="ident">postprocess</span></span>(<span>self, build)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postprocess(self, build):
    for step in self.postprocess_steps:
        if step == &#39;effects&#39;:
            build = add_effects(build, self.effects)
        if step == &#39;volume&#39;:
            build += self.volume
        if step == &#39;pan&#39;:
            build = build.pan(self.pan)
    return build</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.set_beats_and_clean"><code class="name flex">
<span>def <span class="ident">set_beats_and_clean</span></span>(<span>self, new)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the Sequencer length while simultaneously removing notes
that are outside of the sequence after the change.
I.e., sets
<code>beats</code> and calls <code><a title="wubwub.tracks._GenericTrack.clean" href="tracks.html#wubwub.tracks._GenericTrack.clean">_GenericTrack.clean()</a></code> for
all tracks.
This is a convenience method which is only useful when
shortening the sequence length.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>new</code></strong> :&ensp;<code>int</code></dt>
<dd>New value for the length of the Sequencer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_beats_and_clean(self, new):
    &#34;&#34;&#34;
    Modifies the Sequencer length while simultaneously removing notes
    that are outside of the sequence after the change.  I.e., sets
    &lt;code&gt;beats&lt;/code&gt; and calls `wubwub.tracks._GenericTrack.clean()` for
    all tracks.  This is a convenience method which is only useful when
    shortening the sequence length.

    Parameters
    ----------
    new : int
        New value for the length of the Sequencer.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self.beats = new
    for track in self.tracks():
        track.clean()</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, printout=True, name_cutoff=None, resolution=1, singlenote='■', multinote='■', empty='□', wrap=32)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, printout=True, name_cutoff=None, resolution=1,
         singlenote=&#39;■&#39;, multinote=&#39;■&#39;, empty=&#39;□&#39;, wrap=32):
    s = seqstring(self,
                  name_cutoff=name_cutoff,
                  resolution=resolution,
                  singlenote=singlenote,
                  multinote=multinote,
                  empty=empty,
                  wrap=wrap)
    if printout:
        print(s)
    else:
        return s</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.soundtest"><code class="name flex">
<span>def <span class="ident">soundtest</span></span>(<span>self, selection=None, postprocess=True, gap=0.5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soundtest(self, selection=None, postprocess=True, gap=.5):
    if selection is None:
        selection = self.tracks()
    else:
        selection = [self.get_track(i) for i in selection]

    for track in selection:
        print(f&#39;Playing sample(s) for &#34;{track.name}&#34;...&#39;)
        time.sleep(.25)
        track.soundtest(postprocess=postprocess)
        time.sleep(gap)</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, beat)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, beat):
    if not isinstance(beat, int):
        raise TypeError(f&#39;Beat for split must be int, not {type(beat)}.&#39;)

    a1, a2 = (1, beat)
    b1, b2 = (beat, self.beats+1)

    a = self.copy(with_notes=False)
    a.beats = a2 - a1
    b = self.copy(with_notes=False)
    b.beats = b2 - b1

    for selftrack, atrack, btrack in zip(self.tracks(), a.tracks(), b.tracks()):
        anotes = selftrack.slice[a1:a2]
        atrack.add_fromdict(anotes)
        bnotes = selftrack.slice[b1:b2]
        btrack.add_fromdict(bnotes, offset=-b.beats)

    return a, b</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.tracknames"><code class="name flex">
<span>def <span class="ident">tracknames</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of the names of each Track currenlty part of this Sequencer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracknames(self):
    &#34;&#34;&#34;Returns a list of the names of each Track currenlty part of this Sequencer.&#34;&#34;&#34;
    return [t.name for t in self._tracks]</code></pre>
</details>
</dd>
<dt id="wubwub.sequencer.Sequencer.tracks"><code class="name flex">
<span>def <span class="ident">tracks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a tuple of the Track objects currently part of this Sequencer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tracks(self):
    &#34;&#34;&#34;Returns a tuple of the Track objects currently part of this Sequencer.&#34;&#34;&#34;
    return tuple(self._tracks)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="wubwub" href="index.html">wubwub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="wubwub.sequencer.join" href="#wubwub.sequencer.join">join</a></code></li>
<li><code><a title="wubwub.sequencer.loop" href="#wubwub.sequencer.loop">loop</a></code></li>
<li><code><a title="wubwub.sequencer.stitch" href="#wubwub.sequencer.stitch">stitch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="wubwub.sequencer.Sequencer" href="#wubwub.sequencer.Sequencer">Sequencer</a></code></h4>
<ul class="two-column">
<li><code><a title="wubwub.sequencer.Sequencer.add_arpeggiator" href="#wubwub.sequencer.Sequencer.add_arpeggiator">add_arpeggiator</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_multisampler" href="#wubwub.sequencer.Sequencer.add_multisampler">add_multisampler</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_sampler" href="#wubwub.sequencer.Sequencer.add_sampler">add_sampler</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.add_samplers" href="#wubwub.sequencer.Sequencer.add_samplers">add_samplers</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.build" href="#wubwub.sequencer.Sequencer.build">build</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.copy" href="#wubwub.sequencer.Sequencer.copy">copy</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.copypaste_section" href="#wubwub.sequencer.Sequencer.copypaste_section">copypaste_section</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.delete_track" href="#wubwub.sequencer.Sequencer.delete_track">delete_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.duplicate_track" href="#wubwub.sequencer.Sequencer.duplicate_track">duplicate_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.export" href="#wubwub.sequencer.Sequencer.export">export</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.get_track" href="#wubwub.sequencer.Sequencer.get_track">get_track</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.loop" href="#wubwub.sequencer.Sequencer.loop">loop</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.loopplay" href="#wubwub.sequencer.Sequencer.loopplay">loopplay</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.play" href="#wubwub.sequencer.Sequencer.play">play</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.plot" href="#wubwub.sequencer.Sequencer.plot">plot</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.postprocess" href="#wubwub.sequencer.Sequencer.postprocess">postprocess</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.set_beats_and_clean" href="#wubwub.sequencer.Sequencer.set_beats_and_clean">set_beats_and_clean</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.show" href="#wubwub.sequencer.Sequencer.show">show</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.soundtest" href="#wubwub.sequencer.Sequencer.soundtest">soundtest</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.split" href="#wubwub.sequencer.Sequencer.split">split</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.tracknames" href="#wubwub.sequencer.Sequencer.tracknames">tracknames</a></code></li>
<li><code><a title="wubwub.sequencer.Sequencer.tracks" href="#wubwub.sequencer.Sequencer.tracks">tracks</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>